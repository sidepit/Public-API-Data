// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sidepit_api.proto

#ifndef PROTOBUF_INCLUDED_sidepit_5fapi_2eproto
#define PROTOBUF_INCLUDED_sidepit_5fapi_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_sidepit_5fapi_2eproto 

namespace protobuf_sidepit_5fapi_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[33];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_sidepit_5fapi_2eproto
class AccountState;
class AccountStateDefaultTypeInternal;
extern AccountStateDefaultTypeInternal _AccountState_default_instance_;
class AccountState_PositionsEntry_DoNotUse;
class AccountState_PositionsEntry_DoNotUseDefaultTypeInternal;
extern AccountState_PositionsEntry_DoNotUseDefaultTypeInternal _AccountState_PositionsEntry_DoNotUse_default_instance_;
class ActiveContractProduct;
class ActiveContractProductDefaultTypeInternal;
extern ActiveContractProductDefaultTypeInternal _ActiveContractProduct_default_instance_;
class ActiveProduct;
class ActiveProductDefaultTypeInternal;
extern ActiveProductDefaultTypeInternal _ActiveProduct_default_instance_;
class AuctionBid;
class AuctionBidDefaultTypeInternal;
extern AuctionBidDefaultTypeInternal _AuctionBid_default_instance_;
class BookOrder;
class BookOrderDefaultTypeInternal;
extern BookOrderDefaultTypeInternal _BookOrder_default_instance_;
class BtcLocks;
class BtcLocksDefaultTypeInternal;
extern BtcLocksDefaultTypeInternal _BtcLocks_default_instance_;
class Contract;
class ContractDefaultTypeInternal;
extern ContractDefaultTypeInternal _Contract_default_instance_;
class ContractBar;
class ContractBarDefaultTypeInternal;
extern ContractBarDefaultTypeInternal _ContractBar_default_instance_;
class DepthItem;
class DepthItemDefaultTypeInternal;
extern DepthItemDefaultTypeInternal _DepthItem_default_instance_;
class EpochBar;
class EpochBarDefaultTypeInternal;
extern EpochBarDefaultTypeInternal _EpochBar_default_instance_;
class EpochEvent;
class EpochEventDefaultTypeInternal;
extern EpochEventDefaultTypeInternal _EpochEvent_default_instance_;
class ExchangeEvent;
class ExchangeEventDefaultTypeInternal;
extern ExchangeEventDefaultTypeInternal _ExchangeEvent_default_instance_;
class ExchangeStatus;
class ExchangeStatusDefaultTypeInternal;
extern ExchangeStatusDefaultTypeInternal _ExchangeStatus_default_instance_;
class FillData;
class FillDataDefaultTypeInternal;
extern FillDataDefaultTypeInternal _FillData_default_instance_;
class MarketData;
class MarketDataDefaultTypeInternal;
extern MarketDataDefaultTypeInternal _MarketData_default_instance_;
class MarketQuote;
class MarketQuoteDefaultTypeInternal;
extern MarketQuoteDefaultTypeInternal _MarketQuote_default_instance_;
class NewOrder;
class NewOrderDefaultTypeInternal;
extern NewOrderDefaultTypeInternal _NewOrder_default_instance_;
class OrderData;
class OrderDataDefaultTypeInternal;
extern OrderDataDefaultTypeInternal _OrderData_default_instance_;
class OrderFills;
class OrderFillsDefaultTypeInternal;
extern OrderFillsDefaultTypeInternal _OrderFills_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class Product;
class ProductDefaultTypeInternal;
extern ProductDefaultTypeInternal _Product_default_instance_;
class ReplyRequest;
class ReplyRequestDefaultTypeInternal;
extern ReplyRequestDefaultTypeInternal _ReplyRequest_default_instance_;
class RequestReply;
class RequestReplyDefaultTypeInternal;
extern RequestReplyDefaultTypeInternal _RequestReply_default_instance_;
class Schedule;
class ScheduleDefaultTypeInternal;
extern ScheduleDefaultTypeInternal _Schedule_default_instance_;
class SessionStatus;
class SessionStatusDefaultTypeInternal;
extern SessionStatusDefaultTypeInternal _SessionStatus_default_instance_;
class SignedTransaction;
class SignedTransactionDefaultTypeInternal;
extern SignedTransactionDefaultTypeInternal _SignedTransaction_default_instance_;
class TraderPositionOrders;
class TraderPositionOrdersDefaultTypeInternal;
extern TraderPositionOrdersDefaultTypeInternal _TraderPositionOrders_default_instance_;
class TraderPositionOrders_OrderfillsEntry_DoNotUse;
class TraderPositionOrders_OrderfillsEntry_DoNotUseDefaultTypeInternal;
extern TraderPositionOrders_OrderfillsEntry_DoNotUseDefaultTypeInternal _TraderPositionOrders_OrderfillsEntry_DoNotUse_default_instance_;
class TradingSession;
class TradingSessionDefaultTypeInternal;
extern TradingSessionDefaultTypeInternal _TradingSession_default_instance_;
class Transaction;
class TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TxBlockStream;
class TxBlockStreamDefaultTypeInternal;
extern TxBlockStreamDefaultTypeInternal _TxBlockStream_default_instance_;
class UnlockRequest;
class UnlockRequestDefaultTypeInternal;
extern UnlockRequestDefaultTypeInternal _UnlockRequest_default_instance_;
namespace google {
namespace protobuf {
template<> ::AccountState* Arena::CreateMaybeMessage<::AccountState>(Arena*);
template<> ::AccountState_PositionsEntry_DoNotUse* Arena::CreateMaybeMessage<::AccountState_PositionsEntry_DoNotUse>(Arena*);
template<> ::ActiveContractProduct* Arena::CreateMaybeMessage<::ActiveContractProduct>(Arena*);
template<> ::ActiveProduct* Arena::CreateMaybeMessage<::ActiveProduct>(Arena*);
template<> ::AuctionBid* Arena::CreateMaybeMessage<::AuctionBid>(Arena*);
template<> ::BookOrder* Arena::CreateMaybeMessage<::BookOrder>(Arena*);
template<> ::BtcLocks* Arena::CreateMaybeMessage<::BtcLocks>(Arena*);
template<> ::Contract* Arena::CreateMaybeMessage<::Contract>(Arena*);
template<> ::ContractBar* Arena::CreateMaybeMessage<::ContractBar>(Arena*);
template<> ::DepthItem* Arena::CreateMaybeMessage<::DepthItem>(Arena*);
template<> ::EpochBar* Arena::CreateMaybeMessage<::EpochBar>(Arena*);
template<> ::EpochEvent* Arena::CreateMaybeMessage<::EpochEvent>(Arena*);
template<> ::ExchangeEvent* Arena::CreateMaybeMessage<::ExchangeEvent>(Arena*);
template<> ::ExchangeStatus* Arena::CreateMaybeMessage<::ExchangeStatus>(Arena*);
template<> ::FillData* Arena::CreateMaybeMessage<::FillData>(Arena*);
template<> ::MarketData* Arena::CreateMaybeMessage<::MarketData>(Arena*);
template<> ::MarketQuote* Arena::CreateMaybeMessage<::MarketQuote>(Arena*);
template<> ::NewOrder* Arena::CreateMaybeMessage<::NewOrder>(Arena*);
template<> ::OrderData* Arena::CreateMaybeMessage<::OrderData>(Arena*);
template<> ::OrderFills* Arena::CreateMaybeMessage<::OrderFills>(Arena*);
template<> ::Position* Arena::CreateMaybeMessage<::Position>(Arena*);
template<> ::Product* Arena::CreateMaybeMessage<::Product>(Arena*);
template<> ::ReplyRequest* Arena::CreateMaybeMessage<::ReplyRequest>(Arena*);
template<> ::RequestReply* Arena::CreateMaybeMessage<::RequestReply>(Arena*);
template<> ::Schedule* Arena::CreateMaybeMessage<::Schedule>(Arena*);
template<> ::SessionStatus* Arena::CreateMaybeMessage<::SessionStatus>(Arena*);
template<> ::SignedTransaction* Arena::CreateMaybeMessage<::SignedTransaction>(Arena*);
template<> ::TraderPositionOrders* Arena::CreateMaybeMessage<::TraderPositionOrders>(Arena*);
template<> ::TraderPositionOrders_OrderfillsEntry_DoNotUse* Arena::CreateMaybeMessage<::TraderPositionOrders_OrderfillsEntry_DoNotUse>(Arena*);
template<> ::TradingSession* Arena::CreateMaybeMessage<::TradingSession>(Arena*);
template<> ::Transaction* Arena::CreateMaybeMessage<::Transaction>(Arena*);
template<> ::TxBlockStream* Arena::CreateMaybeMessage<::TxBlockStream>(Arena*);
template<> ::UnlockRequest* Arena::CreateMaybeMessage<::UnlockRequest>(Arena*);
}  // namespace protobuf
}  // namespace google

enum UnlockRequest_AmountType {
  UnlockRequest_AmountType_NONE = 0,
  UnlockRequest_AmountType_MAX = 1,
  UnlockRequest_AmountType_MIN = 2,
  UnlockRequest_AmountType_EXPLICIT = 3,
  UnlockRequest_AmountType_UnlockRequest_AmountType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  UnlockRequest_AmountType_UnlockRequest_AmountType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool UnlockRequest_AmountType_IsValid(int value);
const UnlockRequest_AmountType UnlockRequest_AmountType_AmountType_MIN = UnlockRequest_AmountType_NONE;
const UnlockRequest_AmountType UnlockRequest_AmountType_AmountType_MAX = UnlockRequest_AmountType_EXPLICIT;
const int UnlockRequest_AmountType_AmountType_ARRAYSIZE = UnlockRequest_AmountType_AmountType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnlockRequest_AmountType_descriptor();
inline const ::std::string& UnlockRequest_AmountType_Name(UnlockRequest_AmountType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnlockRequest_AmountType_descriptor(), value);
}
inline bool UnlockRequest_AmountType_Parse(
    const ::std::string& name, UnlockRequest_AmountType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnlockRequest_AmountType>(
    UnlockRequest_AmountType_descriptor(), name, value);
}
enum ExchangeState {
  EXCHANGE_UNKNOWN = 0,
  EXCHANGE_PENDING_OPEN = 1,
  EXCHANGE_OPEN = 2,
  EXCHANGE_RECOVERING = 3,
  EXCHANGE_CLOSING = 4,
  EXCHANGE_SETTLED = 5,
  EXCHANGE_CLOSED = 6,
  ExchangeState_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ExchangeState_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ExchangeState_IsValid(int value);
const ExchangeState ExchangeState_MIN = EXCHANGE_UNKNOWN;
const ExchangeState ExchangeState_MAX = EXCHANGE_CLOSED;
const int ExchangeState_ARRAYSIZE = ExchangeState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ExchangeState_descriptor();
inline const ::std::string& ExchangeState_Name(ExchangeState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ExchangeState_descriptor(), value);
}
inline bool ExchangeState_Parse(
    const ::std::string& name, ExchangeState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ExchangeState>(
    ExchangeState_descriptor(), name, value);
}
enum ReplyRequestTypes {
  NONE = 0,
  ACTIVE_PRODUCT = 1,
  POSITIONS = 2,
  QUOTE = 4,
  ReplyRequestTypes_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ReplyRequestTypes_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ReplyRequestTypes_IsValid(int value);
const ReplyRequestTypes ReplyRequestTypes_MIN = NONE;
const ReplyRequestTypes ReplyRequestTypes_MAX = QUOTE;
const int ReplyRequestTypes_ARRAYSIZE = ReplyRequestTypes_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReplyRequestTypes_descriptor();
inline const ::std::string& ReplyRequestTypes_Name(ReplyRequestTypes value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReplyRequestTypes_descriptor(), value);
}
inline bool ReplyRequestTypes_Parse(
    const ::std::string& name, ReplyRequestTypes* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReplyRequestTypes>(
    ReplyRequestTypes_descriptor(), name, value);
}
// ===================================================================

class Transaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Transaction) */ {
 public:
  Transaction();
  virtual ~Transaction();

  Transaction(const Transaction& from);

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(Transaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Transaction& default_instance();

  enum TxCase {
    kNewOrder = 20,
    kCancelOrderid = 30,
    kAuctionBid = 40,
    kUnlockReq = 50,
    TX_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Transaction* other);
  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return CreateMaybeMessage<Transaction>(NULL);
  }

  Transaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Transaction& from);
  void MergeFrom(const Transaction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sidepit_id = 101;
  void clear_sidepit_id();
  static const int kSidepitIdFieldNumber = 101;
  const ::std::string& sidepit_id() const;
  void set_sidepit_id(const ::std::string& value);
  #if LANG_CXX11
  void set_sidepit_id(::std::string&& value);
  #endif
  void set_sidepit_id(const char* value);
  void set_sidepit_id(const char* value, size_t size);
  ::std::string* mutable_sidepit_id();
  ::std::string* release_sidepit_id();
  void set_allocated_sidepit_id(::std::string* sidepit_id);

  // int32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // uint64 timestamp = 10;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // .NewOrder new_order = 20;
  bool has_new_order() const;
  void clear_new_order();
  static const int kNewOrderFieldNumber = 20;
  private:
  const ::NewOrder& _internal_new_order() const;
  public:
  const ::NewOrder& new_order() const;
  ::NewOrder* release_new_order();
  ::NewOrder* mutable_new_order();
  void set_allocated_new_order(::NewOrder* new_order);

  // string cancel_orderid = 30;
  private:
  bool has_cancel_orderid() const;
  public:
  void clear_cancel_orderid();
  static const int kCancelOrderidFieldNumber = 30;
  const ::std::string& cancel_orderid() const;
  void set_cancel_orderid(const ::std::string& value);
  #if LANG_CXX11
  void set_cancel_orderid(::std::string&& value);
  #endif
  void set_cancel_orderid(const char* value);
  void set_cancel_orderid(const char* value, size_t size);
  ::std::string* mutable_cancel_orderid();
  ::std::string* release_cancel_orderid();
  void set_allocated_cancel_orderid(::std::string* cancel_orderid);

  // .AuctionBid auction_bid = 40;
  bool has_auction_bid() const;
  void clear_auction_bid();
  static const int kAuctionBidFieldNumber = 40;
  private:
  const ::AuctionBid& _internal_auction_bid() const;
  public:
  const ::AuctionBid& auction_bid() const;
  ::AuctionBid* release_auction_bid();
  ::AuctionBid* mutable_auction_bid();
  void set_allocated_auction_bid(::AuctionBid* auction_bid);

  // .UnlockRequest unlock_req = 50;
  bool has_unlock_req() const;
  void clear_unlock_req();
  static const int kUnlockReqFieldNumber = 50;
  private:
  const ::UnlockRequest& _internal_unlock_req() const;
  public:
  const ::UnlockRequest& unlock_req() const;
  ::UnlockRequest* release_unlock_req();
  ::UnlockRequest* mutable_unlock_req();
  void set_allocated_unlock_req(::UnlockRequest* unlock_req);

  void clear_tx();
  TxCase tx_case() const;
  // @@protoc_insertion_point(class_scope:Transaction)
 private:
  void set_has_new_order();
  void set_has_cancel_orderid();
  void set_has_auction_bid();
  void set_has_unlock_req();

  inline bool has_tx() const;
  inline void clear_has_tx();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sidepit_id_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::uint64 timestamp_;
  union TxUnion {
    TxUnion() {}
    ::NewOrder* new_order_;
    ::google::protobuf::internal::ArenaStringPtr cancel_orderid_;
    ::AuctionBid* auction_bid_;
    ::UnlockRequest* unlock_req_;
  } tx_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SignedTransaction : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SignedTransaction) */ {
 public:
  SignedTransaction();
  virtual ~SignedTransaction();

  SignedTransaction(const SignedTransaction& from);

  inline SignedTransaction& operator=(const SignedTransaction& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SignedTransaction(SignedTransaction&& from) noexcept
    : SignedTransaction() {
    *this = ::std::move(from);
  }

  inline SignedTransaction& operator=(SignedTransaction&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SignedTransaction& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SignedTransaction* internal_default_instance() {
    return reinterpret_cast<const SignedTransaction*>(
               &_SignedTransaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(SignedTransaction* other);
  friend void swap(SignedTransaction& a, SignedTransaction& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SignedTransaction* New() const final {
    return CreateMaybeMessage<SignedTransaction>(NULL);
  }

  SignedTransaction* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SignedTransaction>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SignedTransaction& from);
  void MergeFrom(const SignedTransaction& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignedTransaction* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string tx_digest = 21;
  void clear_tx_digest();
  static const int kTxDigestFieldNumber = 21;
  const ::std::string& tx_digest() const;
  void set_tx_digest(const ::std::string& value);
  #if LANG_CXX11
  void set_tx_digest(::std::string&& value);
  #endif
  void set_tx_digest(const char* value);
  void set_tx_digest(const char* value, size_t size);
  ::std::string* mutable_tx_digest();
  ::std::string* release_tx_digest();
  void set_allocated_tx_digest(::std::string* tx_digest);

  // string pubkey = 31;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 31;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const char* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // string signature = 111;
  void clear_signature();
  static const int kSignatureFieldNumber = 111;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const char* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // .Transaction transaction = 11;
  bool has_transaction() const;
  void clear_transaction();
  static const int kTransactionFieldNumber = 11;
  private:
  const ::Transaction& _internal_transaction() const;
  public:
  const ::Transaction& transaction() const;
  ::Transaction* release_transaction();
  ::Transaction* mutable_transaction();
  void set_allocated_transaction(::Transaction* transaction);

  // int32 signature_version = 2;
  void clear_signature_version();
  static const int kSignatureVersionFieldNumber = 2;
  ::google::protobuf::int32 signature_version() const;
  void set_signature_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SignedTransaction)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr tx_digest_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::Transaction* transaction_;
  ::google::protobuf::int32 signature_version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NewOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:NewOrder) */ {
 public:
  NewOrder();
  virtual ~NewOrder();

  NewOrder(const NewOrder& from);

  inline NewOrder& operator=(const NewOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NewOrder(NewOrder&& from) noexcept
    : NewOrder() {
    *this = ::std::move(from);
  }

  inline NewOrder& operator=(NewOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const NewOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NewOrder* internal_default_instance() {
    return reinterpret_cast<const NewOrder*>(
               &_NewOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(NewOrder* other);
  friend void swap(NewOrder& a, NewOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NewOrder* New() const final {
    return CreateMaybeMessage<NewOrder>(NULL);
  }

  NewOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NewOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NewOrder& from);
  void MergeFrom(const NewOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NewOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ticker = 40;
  void clear_ticker();
  static const int kTickerFieldNumber = 40;
  const ::std::string& ticker() const;
  void set_ticker(const ::std::string& value);
  #if LANG_CXX11
  void set_ticker(::std::string&& value);
  #endif
  void set_ticker(const char* value);
  void set_ticker(const char* value, size_t size);
  ::std::string* mutable_ticker();
  ::std::string* release_ticker();
  void set_allocated_ticker(::std::string* ticker);

  // int32 price = 30;
  void clear_price();
  static const int kPriceFieldNumber = 30;
  ::google::protobuf::int32 price() const;
  void set_price(::google::protobuf::int32 value);

  // sint32 side = 11;
  void clear_side();
  static const int kSideFieldNumber = 11;
  ::google::protobuf::int32 side() const;
  void set_side(::google::protobuf::int32 value);

  // int32 size = 20;
  void clear_size();
  static const int kSizeFieldNumber = 20;
  ::google::protobuf::int32 size() const;
  void set_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:NewOrder)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticker_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 side_;
  ::google::protobuf::int32 size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AuctionBid : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AuctionBid) */ {
 public:
  AuctionBid();
  virtual ~AuctionBid();

  AuctionBid(const AuctionBid& from);

  inline AuctionBid& operator=(const AuctionBid& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AuctionBid(AuctionBid&& from) noexcept
    : AuctionBid() {
    *this = ::std::move(from);
  }

  inline AuctionBid& operator=(AuctionBid&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AuctionBid& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AuctionBid* internal_default_instance() {
    return reinterpret_cast<const AuctionBid*>(
               &_AuctionBid_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AuctionBid* other);
  friend void swap(AuctionBid& a, AuctionBid& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AuctionBid* New() const final {
    return CreateMaybeMessage<AuctionBid>(NULL);
  }

  AuctionBid* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AuctionBid>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AuctionBid& from);
  void MergeFrom(const AuctionBid& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuctionBid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 20;
  void clear_hash();
  static const int kHashFieldNumber = 20;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // string ordering_salt = 30;
  void clear_ordering_salt();
  static const int kOrderingSaltFieldNumber = 30;
  const ::std::string& ordering_salt() const;
  void set_ordering_salt(const ::std::string& value);
  #if LANG_CXX11
  void set_ordering_salt(::std::string&& value);
  #endif
  void set_ordering_salt(const char* value);
  void set_ordering_salt(const char* value, size_t size);
  ::std::string* mutable_ordering_salt();
  ::std::string* release_ordering_salt();
  void set_allocated_ordering_salt(::std::string* ordering_salt);

  // int32 bid = 40;
  void clear_bid();
  static const int kBidFieldNumber = 40;
  ::google::protobuf::int32 bid() const;
  void set_bid(::google::protobuf::int32 value);

  // uint64 epoch = 10;
  void clear_epoch();
  static const int kEpochFieldNumber = 10;
  ::google::protobuf::uint64 epoch() const;
  void set_epoch(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:AuctionBid)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr ordering_salt_;
  ::google::protobuf::int32 bid_;
  ::google::protobuf::uint64 epoch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnlockRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:UnlockRequest) */ {
 public:
  UnlockRequest();
  virtual ~UnlockRequest();

  UnlockRequest(const UnlockRequest& from);

  inline UnlockRequest& operator=(const UnlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnlockRequest(UnlockRequest&& from) noexcept
    : UnlockRequest() {
    *this = ::std::move(from);
  }

  inline UnlockRequest& operator=(UnlockRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnlockRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnlockRequest* internal_default_instance() {
    return reinterpret_cast<const UnlockRequest*>(
               &_UnlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(UnlockRequest* other);
  friend void swap(UnlockRequest& a, UnlockRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnlockRequest* New() const final {
    return CreateMaybeMessage<UnlockRequest>(NULL);
  }

  UnlockRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnlockRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnlockRequest& from);
  void MergeFrom(const UnlockRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnlockRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UnlockRequest_AmountType AmountType;
  static const AmountType NONE =
    UnlockRequest_AmountType_NONE;
  static const AmountType MAX =
    UnlockRequest_AmountType_MAX;
  static const AmountType MIN =
    UnlockRequest_AmountType_MIN;
  static const AmountType EXPLICIT =
    UnlockRequest_AmountType_EXPLICIT;
  static inline bool AmountType_IsValid(int value) {
    return UnlockRequest_AmountType_IsValid(value);
  }
  static const AmountType AmountType_MIN =
    UnlockRequest_AmountType_AmountType_MIN;
  static const AmountType AmountType_MAX =
    UnlockRequest_AmountType_AmountType_MAX;
  static const int AmountType_ARRAYSIZE =
    UnlockRequest_AmountType_AmountType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  AmountType_descriptor() {
    return UnlockRequest_AmountType_descriptor();
  }
  static inline const ::std::string& AmountType_Name(AmountType value) {
    return UnlockRequest_AmountType_Name(value);
  }
  static inline bool AmountType_Parse(const ::std::string& name,
      AmountType* value) {
    return UnlockRequest_AmountType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .UnlockRequest.AmountType minmax = 20;
  void clear_minmax();
  static const int kMinmaxFieldNumber = 20;
  ::UnlockRequest_AmountType minmax() const;
  void set_minmax(::UnlockRequest_AmountType value);

  // uint64 explicit_amount = 30;
  void clear_explicit_amount();
  static const int kExplicitAmountFieldNumber = 30;
  ::google::protobuf::uint64 explicit_amount() const;
  void set_explicit_amount(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:UnlockRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int minmax_;
  ::google::protobuf::uint64 explicit_amount_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EpochEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EpochEvent) */ {
 public:
  EpochEvent();
  virtual ~EpochEvent();

  EpochEvent(const EpochEvent& from);

  inline EpochEvent& operator=(const EpochEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EpochEvent(EpochEvent&& from) noexcept
    : EpochEvent() {
    *this = ::std::move(from);
  }

  inline EpochEvent& operator=(EpochEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EpochEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EpochEvent* internal_default_instance() {
    return reinterpret_cast<const EpochEvent*>(
               &_EpochEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(EpochEvent* other);
  friend void swap(EpochEvent& a, EpochEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EpochEvent* New() const final {
    return CreateMaybeMessage<EpochEvent>(NULL);
  }

  EpochEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EpochEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EpochEvent& from);
  void MergeFrom(const EpochEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpochEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string hash = 20;
  void clear_hash();
  static const int kHashFieldNumber = 20;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const char* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // string id = 100;
  void clear_id();
  static const int kIdFieldNumber = 100;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // bytes signature = 110;
  void clear_signature();
  static const int kSignatureFieldNumber = 110;
  const ::std::string& signature() const;
  void set_signature(const ::std::string& value);
  #if LANG_CXX11
  void set_signature(::std::string&& value);
  #endif
  void set_signature(const char* value);
  void set_signature(const void* value, size_t size);
  ::std::string* mutable_signature();
  ::std::string* release_signature();
  void set_allocated_signature(::std::string* signature);

  // uint64 epoch = 10;
  void clear_epoch();
  static const int kEpochFieldNumber = 10;
  ::google::protobuf::uint64 epoch() const;
  void set_epoch(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:EpochEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr signature_;
  ::google::protobuf::uint64 epoch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeEvent : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ExchangeEvent) */ {
 public:
  ExchangeEvent();
  virtual ~ExchangeEvent();

  ExchangeEvent(const ExchangeEvent& from);

  inline ExchangeEvent& operator=(const ExchangeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeEvent(ExchangeEvent&& from) noexcept
    : ExchangeEvent() {
    *this = ::std::move(from);
  }

  inline ExchangeEvent& operator=(ExchangeEvent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeEvent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeEvent* internal_default_instance() {
    return reinterpret_cast<const ExchangeEvent*>(
               &_ExchangeEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ExchangeEvent* other);
  friend void swap(ExchangeEvent& a, ExchangeEvent& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeEvent* New() const final {
    return CreateMaybeMessage<ExchangeEvent>(NULL);
  }

  ExchangeEvent* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeEvent>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeEvent& from);
  void MergeFrom(const ExchangeEvent& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeEvent* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ExchangeState state = 10;
  void clear_state();
  static const int kStateFieldNumber = 10;
  ::ExchangeState state() const;
  void set_state(::ExchangeState value);

  // @@protoc_insertion_point(class_scope:ExchangeEvent)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int state_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TxBlockStream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TxBlockStream) */ {
 public:
  TxBlockStream();
  virtual ~TxBlockStream();

  TxBlockStream(const TxBlockStream& from);

  inline TxBlockStream& operator=(const TxBlockStream& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TxBlockStream(TxBlockStream&& from) noexcept
    : TxBlockStream() {
    *this = ::std::move(from);
  }

  inline TxBlockStream& operator=(TxBlockStream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TxBlockStream& default_instance();

  enum TxepochCase {
    kEpochEvent = 25,
    kStx = 31,
    kExchangeEvent = 40,
    TXEPOCH_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TxBlockStream* internal_default_instance() {
    return reinterpret_cast<const TxBlockStream*>(
               &_TxBlockStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(TxBlockStream* other);
  friend void swap(TxBlockStream& a, TxBlockStream& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TxBlockStream* New() const final {
    return CreateMaybeMessage<TxBlockStream>(NULL);
  }

  TxBlockStream* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TxBlockStream>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TxBlockStream& from);
  void MergeFrom(const TxBlockStream& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxBlockStream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ExchangeState estate = 20;
  void clear_estate();
  static const int kEstateFieldNumber = 20;
  ::ExchangeState estate() const;
  void set_estate(::ExchangeState value);

  // uint64 epoch = 10;
  void clear_epoch();
  static const int kEpochFieldNumber = 10;
  ::google::protobuf::uint64 epoch() const;
  void set_epoch(::google::protobuf::uint64 value);

  // .EpochEvent epoch_event = 25;
  bool has_epoch_event() const;
  void clear_epoch_event();
  static const int kEpochEventFieldNumber = 25;
  private:
  const ::EpochEvent& _internal_epoch_event() const;
  public:
  const ::EpochEvent& epoch_event() const;
  ::EpochEvent* release_epoch_event();
  ::EpochEvent* mutable_epoch_event();
  void set_allocated_epoch_event(::EpochEvent* epoch_event);

  // .SignedTransaction stx = 31;
  bool has_stx() const;
  void clear_stx();
  static const int kStxFieldNumber = 31;
  private:
  const ::SignedTransaction& _internal_stx() const;
  public:
  const ::SignedTransaction& stx() const;
  ::SignedTransaction* release_stx();
  ::SignedTransaction* mutable_stx();
  void set_allocated_stx(::SignedTransaction* stx);

  // .ExchangeEvent exchange_event = 40;
  bool has_exchange_event() const;
  void clear_exchange_event();
  static const int kExchangeEventFieldNumber = 40;
  private:
  const ::ExchangeEvent& _internal_exchange_event() const;
  public:
  const ::ExchangeEvent& exchange_event() const;
  ::ExchangeEvent* release_exchange_event();
  ::ExchangeEvent* mutable_exchange_event();
  void set_allocated_exchange_event(::ExchangeEvent* exchange_event);

  void clear_txepoch();
  TxepochCase txepoch_case() const;
  // @@protoc_insertion_point(class_scope:TxBlockStream)
 private:
  void set_has_epoch_event();
  void set_has_stx();
  void set_has_exchange_event();

  inline bool has_txepoch() const;
  inline void clear_has_txepoch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int estate_;
  ::google::protobuf::uint64 epoch_;
  union TxepochUnion {
    TxepochUnion() {}
    ::EpochEvent* epoch_event_;
    ::SignedTransaction* stx_;
    ::ExchangeEvent* exchange_event_;
  } txepoch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketQuote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MarketQuote) */ {
 public:
  MarketQuote();
  virtual ~MarketQuote();

  MarketQuote(const MarketQuote& from);

  inline MarketQuote& operator=(const MarketQuote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketQuote(MarketQuote&& from) noexcept
    : MarketQuote() {
    *this = ::std::move(from);
  }

  inline MarketQuote& operator=(MarketQuote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketQuote& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketQuote* internal_default_instance() {
    return reinterpret_cast<const MarketQuote*>(
               &_MarketQuote_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(MarketQuote* other);
  friend void swap(MarketQuote& a, MarketQuote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketQuote* New() const final {
    return CreateMaybeMessage<MarketQuote>(NULL);
  }

  MarketQuote* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketQuote>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketQuote& from);
  void MergeFrom(const MarketQuote& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketQuote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ticker = 80;
  void clear_ticker();
  static const int kTickerFieldNumber = 80;
  const ::std::string& ticker() const;
  void set_ticker(const ::std::string& value);
  #if LANG_CXX11
  void set_ticker(::std::string&& value);
  #endif
  void set_ticker(const char* value);
  void set_ticker(const char* value, size_t size);
  ::std::string* mutable_ticker();
  ::std::string* release_ticker();
  void set_allocated_ticker(::std::string* ticker);

  // bool upordown = 70;
  void clear_upordown();
  static const int kUpordownFieldNumber = 70;
  bool upordown() const;
  void set_upordown(bool value);

  // int32 bidsize = 10;
  void clear_bidsize();
  static const int kBidsizeFieldNumber = 10;
  ::google::protobuf::int32 bidsize() const;
  void set_bidsize(::google::protobuf::int32 value);

  // int32 bid = 20;
  void clear_bid();
  static const int kBidFieldNumber = 20;
  ::google::protobuf::int32 bid() const;
  void set_bid(::google::protobuf::int32 value);

  // int32 ask = 30;
  void clear_ask();
  static const int kAskFieldNumber = 30;
  ::google::protobuf::int32 ask() const;
  void set_ask(::google::protobuf::int32 value);

  // int32 asksize = 40;
  void clear_asksize();
  static const int kAsksizeFieldNumber = 40;
  ::google::protobuf::int32 asksize() const;
  void set_asksize(::google::protobuf::int32 value);

  // int32 last = 50;
  void clear_last();
  static const int kLastFieldNumber = 50;
  ::google::protobuf::int32 last() const;
  void set_last(::google::protobuf::int32 value);

  // int32 lastsize = 60;
  void clear_lastsize();
  static const int kLastsizeFieldNumber = 60;
  ::google::protobuf::int32 lastsize() const;
  void set_lastsize(::google::protobuf::int32 value);

  // uint64 epoch = 90;
  void clear_epoch();
  static const int kEpochFieldNumber = 90;
  ::google::protobuf::uint64 epoch() const;
  void set_epoch(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:MarketQuote)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticker_;
  bool upordown_;
  ::google::protobuf::int32 bidsize_;
  ::google::protobuf::int32 bid_;
  ::google::protobuf::int32 ask_;
  ::google::protobuf::int32 asksize_;
  ::google::protobuf::int32 last_;
  ::google::protobuf::int32 lastsize_;
  ::google::protobuf::uint64 epoch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EpochBar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:EpochBar) */ {
 public:
  EpochBar();
  virtual ~EpochBar();

  EpochBar(const EpochBar& from);

  inline EpochBar& operator=(const EpochBar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EpochBar(EpochBar&& from) noexcept
    : EpochBar() {
    *this = ::std::move(from);
  }

  inline EpochBar& operator=(EpochBar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const EpochBar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EpochBar* internal_default_instance() {
    return reinterpret_cast<const EpochBar*>(
               &_EpochBar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(EpochBar* other);
  friend void swap(EpochBar& a, EpochBar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EpochBar* New() const final {
    return CreateMaybeMessage<EpochBar>(NULL);
  }

  EpochBar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EpochBar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EpochBar& from);
  void MergeFrom(const EpochBar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpochBar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ticker = 10;
  void clear_ticker();
  static const int kTickerFieldNumber = 10;
  const ::std::string& ticker() const;
  void set_ticker(const ::std::string& value);
  #if LANG_CXX11
  void set_ticker(::std::string&& value);
  #endif
  void set_ticker(const char* value);
  void set_ticker(const char* value, size_t size);
  ::std::string* mutable_ticker();
  ::std::string* release_ticker();
  void set_allocated_ticker(::std::string* ticker);

  // int32 volume = 60;
  void clear_volume();
  static const int kVolumeFieldNumber = 60;
  ::google::protobuf::int32 volume() const;
  void set_volume(::google::protobuf::int32 value);

  // uint64 epoch = 15;
  void clear_epoch();
  static const int kEpochFieldNumber = 15;
  ::google::protobuf::uint64 epoch() const;
  void set_epoch(::google::protobuf::uint64 value);

  // int32 open = 20;
  void clear_open();
  static const int kOpenFieldNumber = 20;
  ::google::protobuf::int32 open() const;
  void set_open(::google::protobuf::int32 value);

  // int32 high = 30;
  void clear_high();
  static const int kHighFieldNumber = 30;
  ::google::protobuf::int32 high() const;
  void set_high(::google::protobuf::int32 value);

  // int32 low = 40;
  void clear_low();
  static const int kLowFieldNumber = 40;
  ::google::protobuf::int32 low() const;
  void set_low(::google::protobuf::int32 value);

  // int32 close = 50;
  void clear_close();
  static const int kCloseFieldNumber = 50;
  ::google::protobuf::int32 close() const;
  void set_close(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:EpochBar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticker_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::uint64 epoch_;
  ::google::protobuf::int32 open_;
  ::google::protobuf::int32 high_;
  ::google::protobuf::int32 low_;
  ::google::protobuf::int32 close_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ContractBar : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ContractBar) */ {
 public:
  ContractBar();
  virtual ~ContractBar();

  ContractBar(const ContractBar& from);

  inline ContractBar& operator=(const ContractBar& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ContractBar(ContractBar&& from) noexcept
    : ContractBar() {
    *this = ::std::move(from);
  }

  inline ContractBar& operator=(ContractBar&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ContractBar& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ContractBar* internal_default_instance() {
    return reinterpret_cast<const ContractBar*>(
               &_ContractBar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ContractBar* other);
  friend void swap(ContractBar& a, ContractBar& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ContractBar* New() const final {
    return CreateMaybeMessage<ContractBar>(NULL);
  }

  ContractBar* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ContractBar>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ContractBar& from);
  void MergeFrom(const ContractBar& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ContractBar* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ticker = 10;
  void clear_ticker();
  static const int kTickerFieldNumber = 10;
  const ::std::string& ticker() const;
  void set_ticker(const ::std::string& value);
  #if LANG_CXX11
  void set_ticker(::std::string&& value);
  #endif
  void set_ticker(const char* value);
  void set_ticker(const char* value, size_t size);
  ::std::string* mutable_ticker();
  ::std::string* release_ticker();
  void set_allocated_ticker(::std::string* ticker);

  // uint64 epoch = 15;
  void clear_epoch();
  static const int kEpochFieldNumber = 15;
  ::google::protobuf::uint64 epoch() const;
  void set_epoch(::google::protobuf::uint64 value);

  // int32 day_open = 20;
  void clear_day_open();
  static const int kDayOpenFieldNumber = 20;
  ::google::protobuf::int32 day_open() const;
  void set_day_open(::google::protobuf::int32 value);

  // int32 day_high = 30;
  void clear_day_high();
  static const int kDayHighFieldNumber = 30;
  ::google::protobuf::int32 day_high() const;
  void set_day_high(::google::protobuf::int32 value);

  // int32 day_low = 40;
  void clear_day_low();
  static const int kDayLowFieldNumber = 40;
  ::google::protobuf::int32 day_low() const;
  void set_day_low(::google::protobuf::int32 value);

  // int32 day_close = 50;
  void clear_day_close();
  static const int kDayCloseFieldNumber = 50;
  ::google::protobuf::int32 day_close() const;
  void set_day_close(::google::protobuf::int32 value);

  // int32 day_volume = 60;
  void clear_day_volume();
  static const int kDayVolumeFieldNumber = 60;
  ::google::protobuf::int32 day_volume() const;
  void set_day_volume(::google::protobuf::int32 value);

  // int32 high = 70;
  void clear_high();
  static const int kHighFieldNumber = 70;
  ::google::protobuf::int32 high() const;
  void set_high(::google::protobuf::int32 value);

  // int32 low = 80;
  void clear_low();
  static const int kLowFieldNumber = 80;
  ::google::protobuf::int32 low() const;
  void set_low(::google::protobuf::int32 value);

  // int32 volume = 90;
  void clear_volume();
  static const int kVolumeFieldNumber = 90;
  ::google::protobuf::int32 volume() const;
  void set_volume(::google::protobuf::int32 value);

  // int32 open_interest = 100;
  void clear_open_interest();
  static const int kOpenInterestFieldNumber = 100;
  ::google::protobuf::int32 open_interest() const;
  void set_open_interest(::google::protobuf::int32 value);

  // int32 previous_close = 110;
  void clear_previous_close();
  static const int kPreviousCloseFieldNumber = 110;
  ::google::protobuf::int32 previous_close() const;
  void set_previous_close(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ContractBar)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticker_;
  ::google::protobuf::uint64 epoch_;
  ::google::protobuf::int32 day_open_;
  ::google::protobuf::int32 day_high_;
  ::google::protobuf::int32 day_low_;
  ::google::protobuf::int32 day_close_;
  ::google::protobuf::int32 day_volume_;
  ::google::protobuf::int32 high_;
  ::google::protobuf::int32 low_;
  ::google::protobuf::int32 volume_;
  ::google::protobuf::int32 open_interest_;
  ::google::protobuf::int32 previous_close_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BookOrder : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BookOrder) */ {
 public:
  BookOrder();
  virtual ~BookOrder();

  BookOrder(const BookOrder& from);

  inline BookOrder& operator=(const BookOrder& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BookOrder(BookOrder&& from) noexcept
    : BookOrder() {
    *this = ::std::move(from);
  }

  inline BookOrder& operator=(BookOrder&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BookOrder& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BookOrder* internal_default_instance() {
    return reinterpret_cast<const BookOrder*>(
               &_BookOrder_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(BookOrder* other);
  friend void swap(BookOrder& a, BookOrder& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BookOrder* New() const final {
    return CreateMaybeMessage<BookOrder>(NULL);
  }

  BookOrder* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BookOrder>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BookOrder& from);
  void MergeFrom(const BookOrder& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BookOrder* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ticker = 70;
  void clear_ticker();
  static const int kTickerFieldNumber = 70;
  const ::std::string& ticker() const;
  void set_ticker(const ::std::string& value);
  #if LANG_CXX11
  void set_ticker(::std::string&& value);
  #endif
  void set_ticker(const char* value);
  void set_ticker(const char* value, size_t size);
  ::std::string* mutable_ticker();
  ::std::string* release_ticker();
  void set_allocated_ticker(::std::string* ticker);

  // string update_time = 80;
  void clear_update_time();
  static const int kUpdateTimeFieldNumber = 80;
  const ::std::string& update_time() const;
  void set_update_time(const ::std::string& value);
  #if LANG_CXX11
  void set_update_time(::std::string&& value);
  #endif
  void set_update_time(const char* value);
  void set_update_time(const char* value, size_t size);
  ::std::string* mutable_update_time();
  ::std::string* release_update_time();
  void set_allocated_update_time(::std::string* update_time);

  // string orderid = 90;
  void clear_orderid();
  static const int kOrderidFieldNumber = 90;
  const ::std::string& orderid() const;
  void set_orderid(const ::std::string& value);
  #if LANG_CXX11
  void set_orderid(::std::string&& value);
  #endif
  void set_orderid(const char* value);
  void set_orderid(const char* value, size_t size);
  ::std::string* mutable_orderid();
  ::std::string* release_orderid();
  void set_allocated_orderid(::std::string* orderid);

  // string traderid = 100;
  void clear_traderid();
  static const int kTraderidFieldNumber = 100;
  const ::std::string& traderid() const;
  void set_traderid(const ::std::string& value);
  #if LANG_CXX11
  void set_traderid(::std::string&& value);
  #endif
  void set_traderid(const char* value);
  void set_traderid(const char* value, size_t size);
  ::std::string* mutable_traderid();
  ::std::string* release_traderid();
  void set_allocated_traderid(::std::string* traderid);

  // sint32 side = 10;
  void clear_side();
  static const int kSideFieldNumber = 10;
  ::google::protobuf::int32 side() const;
  void set_side(::google::protobuf::int32 value);

  // int32 price = 20;
  void clear_price();
  static const int kPriceFieldNumber = 20;
  ::google::protobuf::int32 price() const;
  void set_price(::google::protobuf::int32 value);

  // int32 open_qty = 30;
  void clear_open_qty();
  static const int kOpenQtyFieldNumber = 30;
  ::google::protobuf::int32 open_qty() const;
  void set_open_qty(::google::protobuf::int32 value);

  // int32 filled_qty = 40;
  void clear_filled_qty();
  static const int kFilledQtyFieldNumber = 40;
  ::google::protobuf::int32 filled_qty() const;
  void set_filled_qty(::google::protobuf::int32 value);

  // int32 remaining_qty = 50;
  void clear_remaining_qty();
  static const int kRemainingQtyFieldNumber = 50;
  ::google::protobuf::int32 remaining_qty() const;
  void set_remaining_qty(::google::protobuf::int32 value);

  // int32 canceled_qty = 60;
  void clear_canceled_qty();
  static const int kCanceledQtyFieldNumber = 60;
  ::google::protobuf::int32 canceled_qty() const;
  void set_canceled_qty(::google::protobuf::int32 value);

  // int32 agres_fill_qty = 62;
  void clear_agres_fill_qty();
  static const int kAgresFillQtyFieldNumber = 62;
  ::google::protobuf::int32 agres_fill_qty() const;
  void set_agres_fill_qty(::google::protobuf::int32 value);

  // float agres_avg_price = 63;
  void clear_agres_avg_price();
  static const int kAgresAvgPriceFieldNumber = 63;
  float agres_avg_price() const;
  void set_agres_avg_price(float value);

  // int32 pass_fill_qty = 64;
  void clear_pass_fill_qty();
  static const int kPassFillQtyFieldNumber = 64;
  ::google::protobuf::int32 pass_fill_qty() const;
  void set_pass_fill_qty(::google::protobuf::int32 value);

  // float avg_price = 65;
  void clear_avg_price();
  static const int kAvgPriceFieldNumber = 65;
  float avg_price() const;
  void set_avg_price(float value);

  // @@protoc_insertion_point(class_scope:BookOrder)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticker_;
  ::google::protobuf::internal::ArenaStringPtr update_time_;
  ::google::protobuf::internal::ArenaStringPtr orderid_;
  ::google::protobuf::internal::ArenaStringPtr traderid_;
  ::google::protobuf::int32 side_;
  ::google::protobuf::int32 price_;
  ::google::protobuf::int32 open_qty_;
  ::google::protobuf::int32 filled_qty_;
  ::google::protobuf::int32 remaining_qty_;
  ::google::protobuf::int32 canceled_qty_;
  ::google::protobuf::int32 agres_fill_qty_;
  float agres_avg_price_;
  ::google::protobuf::int32 pass_fill_qty_;
  float avg_price_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DepthItem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:DepthItem) */ {
 public:
  DepthItem();
  virtual ~DepthItem();

  DepthItem(const DepthItem& from);

  inline DepthItem& operator=(const DepthItem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DepthItem(DepthItem&& from) noexcept
    : DepthItem() {
    *this = ::std::move(from);
  }

  inline DepthItem& operator=(DepthItem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DepthItem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DepthItem* internal_default_instance() {
    return reinterpret_cast<const DepthItem*>(
               &_DepthItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(DepthItem* other);
  friend void swap(DepthItem& a, DepthItem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DepthItem* New() const final {
    return CreateMaybeMessage<DepthItem>(NULL);
  }

  DepthItem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DepthItem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DepthItem& from);
  void MergeFrom(const DepthItem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DepthItem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 as = 60;
  void clear_as();
  static const int kAsFieldNumber = 60;
  ::google::protobuf::int32 as() const;
  void set_as(::google::protobuf::int32 value);

  // int32 level = 10;
  void clear_level();
  static const int kLevelFieldNumber = 10;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // int32 b = 30;
  void clear_b();
  static const int kBFieldNumber = 30;
  ::google::protobuf::int32 b() const;
  void set_b(::google::protobuf::int32 value);

  // int32 a = 40;
  void clear_a();
  static const int kAFieldNumber = 40;
  ::google::protobuf::int32 a() const;
  void set_a(::google::protobuf::int32 value);

  // int32 bs = 50;
  void clear_bs();
  static const int kBsFieldNumber = 50;
  ::google::protobuf::int32 bs() const;
  void set_bs(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:DepthItem)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 as_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 b_;
  ::google::protobuf::int32 a_;
  ::google::protobuf::int32 bs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MarketData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MarketData) */ {
 public:
  MarketData();
  virtual ~MarketData();

  MarketData(const MarketData& from);

  inline MarketData& operator=(const MarketData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MarketData(MarketData&& from) noexcept
    : MarketData() {
    *this = ::std::move(from);
  }

  inline MarketData& operator=(MarketData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MarketData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MarketData* internal_default_instance() {
    return reinterpret_cast<const MarketData*>(
               &_MarketData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(MarketData* other);
  friend void swap(MarketData& a, MarketData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MarketData* New() const final {
    return CreateMaybeMessage<MarketData>(NULL);
  }

  MarketData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MarketData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MarketData& from);
  void MergeFrom(const MarketData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MarketData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .DepthItem depth = 40;
  int depth_size() const;
  void clear_depth();
  static const int kDepthFieldNumber = 40;
  ::DepthItem* mutable_depth(int index);
  ::google::protobuf::RepeatedPtrField< ::DepthItem >*
      mutable_depth();
  const ::DepthItem& depth(int index) const;
  ::DepthItem* add_depth();
  const ::google::protobuf::RepeatedPtrField< ::DepthItem >&
      depth() const;

  // .EpochBar bar = 20;
  bool has_bar() const;
  void clear_bar();
  static const int kBarFieldNumber = 20;
  private:
  const ::EpochBar& _internal_bar() const;
  public:
  const ::EpochBar& bar() const;
  ::EpochBar* release_bar();
  ::EpochBar* mutable_bar();
  void set_allocated_bar(::EpochBar* bar);

  // .MarketQuote quote = 30;
  bool has_quote() const;
  void clear_quote();
  static const int kQuoteFieldNumber = 30;
  private:
  const ::MarketQuote& _internal_quote() const;
  public:
  const ::MarketQuote& quote() const;
  ::MarketQuote* release_quote();
  ::MarketQuote* mutable_quote();
  void set_allocated_quote(::MarketQuote* quote);

  // int32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // uint64 epoch = 10;
  void clear_epoch();
  static const int kEpochFieldNumber = 10;
  ::google::protobuf::uint64 epoch() const;
  void set_epoch(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:MarketData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::DepthItem > depth_;
  ::EpochBar* bar_;
  ::MarketQuote* quote_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::uint64 epoch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FillData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:FillData) */ {
 public:
  FillData();
  virtual ~FillData();

  FillData(const FillData& from);

  inline FillData& operator=(const FillData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FillData(FillData&& from) noexcept
    : FillData() {
    *this = ::std::move(from);
  }

  inline FillData& operator=(FillData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FillData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FillData* internal_default_instance() {
    return reinterpret_cast<const FillData*>(
               &_FillData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(FillData* other);
  friend void swap(FillData& a, FillData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FillData* New() const final {
    return CreateMaybeMessage<FillData>(NULL);
  }

  FillData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FillData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FillData& from);
  void MergeFrom(const FillData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FillData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string agressiveid = 10;
  void clear_agressiveid();
  static const int kAgressiveidFieldNumber = 10;
  const ::std::string& agressiveid() const;
  void set_agressiveid(const ::std::string& value);
  #if LANG_CXX11
  void set_agressiveid(::std::string&& value);
  #endif
  void set_agressiveid(const char* value);
  void set_agressiveid(const char* value, size_t size);
  ::std::string* mutable_agressiveid();
  ::std::string* release_agressiveid();
  void set_allocated_agressiveid(::std::string* agressiveid);

  // string passiveid = 20;
  void clear_passiveid();
  static const int kPassiveidFieldNumber = 20;
  const ::std::string& passiveid() const;
  void set_passiveid(const ::std::string& value);
  #if LANG_CXX11
  void set_passiveid(::std::string&& value);
  #endif
  void set_passiveid(const char* value);
  void set_passiveid(const char* value, size_t size);
  ::std::string* mutable_passiveid();
  ::std::string* release_passiveid();
  void set_allocated_passiveid(::std::string* passiveid);

  // int32 agressive_side = 50;
  void clear_agressive_side();
  static const int kAgressiveSideFieldNumber = 50;
  ::google::protobuf::int32 agressive_side() const;
  void set_agressive_side(::google::protobuf::int32 value);

  // uint32 price = 30;
  void clear_price();
  static const int kPriceFieldNumber = 30;
  ::google::protobuf::uint32 price() const;
  void set_price(::google::protobuf::uint32 value);

  // uint32 qty = 40;
  void clear_qty();
  static const int kQtyFieldNumber = 40;
  ::google::protobuf::uint32 qty() const;
  void set_qty(::google::protobuf::uint32 value);

  // uint64 microtime = 60;
  void clear_microtime();
  static const int kMicrotimeFieldNumber = 60;
  ::google::protobuf::uint64 microtime() const;
  void set_microtime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:FillData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr agressiveid_;
  ::google::protobuf::internal::ArenaStringPtr passiveid_;
  ::google::protobuf::int32 agressive_side_;
  ::google::protobuf::uint32 price_;
  ::google::protobuf::uint32 qty_;
  ::google::protobuf::uint64 microtime_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OrderData) */ {
 public:
  OrderData();
  virtual ~OrderData();

  OrderData(const OrderData& from);

  inline OrderData& operator=(const OrderData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderData(OrderData&& from) noexcept
    : OrderData() {
    *this = ::std::move(from);
  }

  inline OrderData& operator=(OrderData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderData* internal_default_instance() {
    return reinterpret_cast<const OrderData*>(
               &_OrderData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(OrderData* other);
  friend void swap(OrderData& a, OrderData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderData* New() const final {
    return CreateMaybeMessage<OrderData>(NULL);
  }

  OrderData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderData& from);
  void MergeFrom(const OrderData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .BookOrder bookorders = 40;
  int bookorders_size() const;
  void clear_bookorders();
  static const int kBookordersFieldNumber = 40;
  ::BookOrder* mutable_bookorders(int index);
  ::google::protobuf::RepeatedPtrField< ::BookOrder >*
      mutable_bookorders();
  const ::BookOrder& bookorders(int index) const;
  ::BookOrder* add_bookorders();
  const ::google::protobuf::RepeatedPtrField< ::BookOrder >&
      bookorders() const;

  // repeated .FillData fills = 50;
  int fills_size() const;
  void clear_fills();
  static const int kFillsFieldNumber = 50;
  ::FillData* mutable_fills(int index);
  ::google::protobuf::RepeatedPtrField< ::FillData >*
      mutable_fills();
  const ::FillData& fills(int index) const;
  ::FillData* add_fills();
  const ::google::protobuf::RepeatedPtrField< ::FillData >&
      fills() const;

  // int32 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int32 version() const;
  void set_version(::google::protobuf::int32 value);

  // uint64 epoch = 10;
  void clear_epoch();
  static const int kEpochFieldNumber = 10;
  ::google::protobuf::uint64 epoch() const;
  void set_epoch(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:OrderData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::BookOrder > bookorders_;
  ::google::protobuf::RepeatedPtrField< ::FillData > fills_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::uint64 epoch_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Contract : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Contract) */ {
 public:
  Contract();
  virtual ~Contract();

  Contract(const Contract& from);

  inline Contract& operator=(const Contract& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Contract(Contract&& from) noexcept
    : Contract() {
    *this = ::std::move(from);
  }

  inline Contract& operator=(Contract&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Contract& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Contract* internal_default_instance() {
    return reinterpret_cast<const Contract*>(
               &_Contract_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Contract* other);
  friend void swap(Contract& a, Contract& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Contract* New() const final {
    return CreateMaybeMessage<Contract>(NULL);
  }

  Contract* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Contract>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Contract& from);
  void MergeFrom(const Contract& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Contract* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string symbol = 10;
  void clear_symbol();
  static const int kSymbolFieldNumber = 10;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // string unit = 30;
  void clear_unit();
  static const int kUnitFieldNumber = 30;
  const ::std::string& unit() const;
  void set_unit(const ::std::string& value);
  #if LANG_CXX11
  void set_unit(::std::string&& value);
  #endif
  void set_unit(const char* value);
  void set_unit(const char* value, size_t size);
  ::std::string* mutable_unit();
  ::std::string* release_unit();
  void set_allocated_unit(::std::string* unit);

  // string price_quote = 40;
  void clear_price_quote();
  static const int kPriceQuoteFieldNumber = 40;
  const ::std::string& price_quote() const;
  void set_price_quote(const ::std::string& value);
  #if LANG_CXX11
  void set_price_quote(::std::string&& value);
  #endif
  void set_price_quote(const char* value);
  void set_price_quote(const char* value, size_t size);
  ::std::string* mutable_price_quote();
  ::std::string* release_price_quote();
  void set_allocated_price_quote(::std::string* price_quote);

  // uint32 unit_size = 20;
  void clear_unit_size();
  static const int kUnitSizeFieldNumber = 20;
  ::google::protobuf::uint32 unit_size() const;
  void set_unit_size(::google::protobuf::uint32 value);

  // int32 price_quote_units = 50;
  void clear_price_quote_units();
  static const int kPriceQuoteUnitsFieldNumber = 50;
  ::google::protobuf::int32 price_quote_units() const;
  void set_price_quote_units(::google::protobuf::int32 value);

  // uint32 tic_min = 60;
  void clear_tic_min();
  static const int kTicMinFieldNumber = 60;
  ::google::protobuf::uint32 tic_min() const;
  void set_tic_min(::google::protobuf::uint32 value);

  // uint32 tic_value = 70;
  void clear_tic_value();
  static const int kTicValueFieldNumber = 70;
  ::google::protobuf::uint32 tic_value() const;
  void set_tic_value(::google::protobuf::uint32 value);

  // uint64 initial_margin = 90;
  void clear_initial_margin();
  static const int kInitialMarginFieldNumber = 90;
  ::google::protobuf::uint64 initial_margin() const;
  void set_initial_margin(::google::protobuf::uint64 value);

  // int32 price_limit_percent = 80;
  void clear_price_limit_percent();
  static const int kPriceLimitPercentFieldNumber = 80;
  ::google::protobuf::int32 price_limit_percent() const;
  void set_price_limit_percent(::google::protobuf::int32 value);

  // int32 position_limits = 110;
  void clear_position_limits();
  static const int kPositionLimitsFieldNumber = 110;
  ::google::protobuf::int32 position_limits() const;
  void set_position_limits(::google::protobuf::int32 value);

  // uint64 maint_margin = 100;
  void clear_maint_margin();
  static const int kMaintMarginFieldNumber = 100;
  ::google::protobuf::uint64 maint_margin() const;
  void set_maint_margin(::google::protobuf::uint64 value);

  // uint64 trading_open_time = 120;
  void clear_trading_open_time();
  static const int kTradingOpenTimeFieldNumber = 120;
  ::google::protobuf::uint64 trading_open_time() const;
  void set_trading_open_time(::google::protobuf::uint64 value);

  // uint64 trading_close_time = 130;
  void clear_trading_close_time();
  static const int kTradingCloseTimeFieldNumber = 130;
  ::google::protobuf::uint64 trading_close_time() const;
  void set_trading_close_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Contract)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::google::protobuf::internal::ArenaStringPtr unit_;
  ::google::protobuf::internal::ArenaStringPtr price_quote_;
  ::google::protobuf::uint32 unit_size_;
  ::google::protobuf::int32 price_quote_units_;
  ::google::protobuf::uint32 tic_min_;
  ::google::protobuf::uint32 tic_value_;
  ::google::protobuf::uint64 initial_margin_;
  ::google::protobuf::int32 price_limit_percent_;
  ::google::protobuf::int32 position_limits_;
  ::google::protobuf::uint64 maint_margin_;
  ::google::protobuf::uint64 trading_open_time_;
  ::google::protobuf::uint64 trading_close_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Product : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Product) */ {
 public:
  Product();
  virtual ~Product();

  Product(const Product& from);

  inline Product& operator=(const Product& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Product(Product&& from) noexcept
    : Product() {
    *this = ::std::move(from);
  }

  inline Product& operator=(Product&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Product& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Product* internal_default_instance() {
    return reinterpret_cast<const Product*>(
               &_Product_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(Product* other);
  friend void swap(Product& a, Product& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Product* New() const final {
    return CreateMaybeMessage<Product>(NULL);
  }

  Product* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Product>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Product& from);
  void MergeFrom(const Product& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Product* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string ticker = 10;
  void clear_ticker();
  static const int kTickerFieldNumber = 10;
  const ::std::string& ticker() const;
  void set_ticker(const ::std::string& value);
  #if LANG_CXX11
  void set_ticker(::std::string&& value);
  #endif
  void set_ticker(const char* value);
  void set_ticker(const char* value, size_t size);
  ::std::string* mutable_ticker();
  ::std::string* release_ticker();
  void set_allocated_ticker(::std::string* ticker);

  // string contract_symbol = 20;
  void clear_contract_symbol();
  static const int kContractSymbolFieldNumber = 20;
  const ::std::string& contract_symbol() const;
  void set_contract_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_contract_symbol(::std::string&& value);
  #endif
  void set_contract_symbol(const char* value);
  void set_contract_symbol(const char* value, size_t size);
  ::std::string* mutable_contract_symbol();
  ::std::string* release_contract_symbol();
  void set_allocated_contract_symbol(::std::string* contract_symbol);

  // bool is_active = 50;
  void clear_is_active();
  static const int kIsActiveFieldNumber = 50;
  bool is_active() const;
  void set_is_active(bool value);

  // uint64 expiration_date = 30;
  void clear_expiration_date();
  static const int kExpirationDateFieldNumber = 30;
  ::google::protobuf::uint64 expiration_date() const;
  void set_expiration_date(::google::protobuf::uint64 value);

  // uint64 start_trading_date = 40;
  void clear_start_trading_date();
  static const int kStartTradingDateFieldNumber = 40;
  ::google::protobuf::uint64 start_trading_date() const;
  void set_start_trading_date(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Product)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr ticker_;
  ::google::protobuf::internal::ArenaStringPtr contract_symbol_;
  bool is_active_;
  ::google::protobuf::uint64 expiration_date_;
  ::google::protobuf::uint64 start_trading_date_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Schedule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Schedule) */ {
 public:
  Schedule();
  virtual ~Schedule();

  Schedule(const Schedule& from);

  inline Schedule& operator=(const Schedule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Schedule(Schedule&& from) noexcept
    : Schedule() {
    *this = ::std::move(from);
  }

  inline Schedule& operator=(Schedule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Schedule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Schedule* internal_default_instance() {
    return reinterpret_cast<const Schedule*>(
               &_Schedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(Schedule* other);
  friend void swap(Schedule& a, Schedule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Schedule* New() const final {
    return CreateMaybeMessage<Schedule>(NULL);
  }

  Schedule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Schedule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Schedule& from);
  void MergeFrom(const Schedule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schedule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string product = 40;
  int product_size() const;
  void clear_product();
  static const int kProductFieldNumber = 40;
  const ::std::string& product(int index) const;
  ::std::string* mutable_product(int index);
  void set_product(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_product(int index, ::std::string&& value);
  #endif
  void set_product(int index, const char* value);
  void set_product(int index, const char* value, size_t size);
  ::std::string* add_product();
  void add_product(const ::std::string& value);
  #if LANG_CXX11
  void add_product(::std::string&& value);
  #endif
  void add_product(const char* value);
  void add_product(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& product() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_product();

  // uint64 date = 10;
  void clear_date();
  static const int kDateFieldNumber = 10;
  ::google::protobuf::uint64 date() const;
  void set_date(::google::protobuf::uint64 value);

  // uint64 trading_open_time = 20;
  void clear_trading_open_time();
  static const int kTradingOpenTimeFieldNumber = 20;
  ::google::protobuf::uint64 trading_open_time() const;
  void set_trading_open_time(::google::protobuf::uint64 value);

  // uint64 trading_close_time = 30;
  void clear_trading_close_time();
  static const int kTradingCloseTimeFieldNumber = 30;
  ::google::protobuf::uint64 trading_close_time() const;
  void set_trading_close_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:Schedule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> product_;
  ::google::protobuf::uint64 date_;
  ::google::protobuf::uint64 trading_open_time_;
  ::google::protobuf::uint64 trading_close_time_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TradingSession : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TradingSession) */ {
 public:
  TradingSession();
  virtual ~TradingSession();

  TradingSession(const TradingSession& from);

  inline TradingSession& operator=(const TradingSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TradingSession(TradingSession&& from) noexcept
    : TradingSession() {
    *this = ::std::move(from);
  }

  inline TradingSession& operator=(TradingSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TradingSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TradingSession* internal_default_instance() {
    return reinterpret_cast<const TradingSession*>(
               &_TradingSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(TradingSession* other);
  friend void swap(TradingSession& a, TradingSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TradingSession* New() const final {
    return CreateMaybeMessage<TradingSession>(NULL);
  }

  TradingSession* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TradingSession>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TradingSession& from);
  void MergeFrom(const TradingSession& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TradingSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_id = 10;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 10;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // string prev_session_id = 50;
  void clear_prev_session_id();
  static const int kPrevSessionIdFieldNumber = 50;
  const ::std::string& prev_session_id() const;
  void set_prev_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_prev_session_id(::std::string&& value);
  #endif
  void set_prev_session_id(const char* value);
  void set_prev_session_id(const char* value, size_t size);
  ::std::string* mutable_prev_session_id();
  ::std::string* release_prev_session_id();
  void set_allocated_prev_session_id(::std::string* prev_session_id);

  // .Schedule schedule = 20;
  bool has_schedule() const;
  void clear_schedule();
  static const int kScheduleFieldNumber = 20;
  private:
  const ::Schedule& _internal_schedule() const;
  public:
  const ::Schedule& schedule() const;
  ::Schedule* release_schedule();
  ::Schedule* mutable_schedule();
  void set_allocated_schedule(::Schedule* schedule);

  // @@protoc_insertion_point(class_scope:TradingSession)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  ::google::protobuf::internal::ArenaStringPtr prev_session_id_;
  ::Schedule* schedule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SessionStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SessionStatus) */ {
 public:
  SessionStatus();
  virtual ~SessionStatus();

  SessionStatus(const SessionStatus& from);

  inline SessionStatus& operator=(const SessionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SessionStatus(SessionStatus&& from) noexcept
    : SessionStatus() {
    *this = ::std::move(from);
  }

  inline SessionStatus& operator=(SessionStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SessionStatus* internal_default_instance() {
    return reinterpret_cast<const SessionStatus*>(
               &_SessionStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(SessionStatus* other);
  friend void swap(SessionStatus& a, SessionStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SessionStatus* New() const final {
    return CreateMaybeMessage<SessionStatus>(NULL);
  }

  SessionStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SessionStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SessionStatus& from);
  void MergeFrom(const SessionStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SessionStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string session_id = 20;
  void clear_session_id();
  static const int kSessionIdFieldNumber = 20;
  const ::std::string& session_id() const;
  void set_session_id(const ::std::string& value);
  #if LANG_CXX11
  void set_session_id(::std::string&& value);
  #endif
  void set_session_id(const char* value);
  void set_session_id(const char* value, size_t size);
  ::std::string* mutable_session_id();
  ::std::string* release_session_id();
  void set_allocated_session_id(::std::string* session_id);

  // .ExchangeState estate = 10;
  void clear_estate();
  static const int kEstateFieldNumber = 10;
  ::ExchangeState estate() const;
  void set_estate(::ExchangeState value);

  // @@protoc_insertion_point(class_scope:SessionStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr session_id_;
  int estate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExchangeStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ExchangeStatus) */ {
 public:
  ExchangeStatus();
  virtual ~ExchangeStatus();

  ExchangeStatus(const ExchangeStatus& from);

  inline ExchangeStatus& operator=(const ExchangeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExchangeStatus(ExchangeStatus&& from) noexcept
    : ExchangeStatus() {
    *this = ::std::move(from);
  }

  inline ExchangeStatus& operator=(ExchangeStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ExchangeStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExchangeStatus* internal_default_instance() {
    return reinterpret_cast<const ExchangeStatus*>(
               &_ExchangeStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ExchangeStatus* other);
  friend void swap(ExchangeStatus& a, ExchangeStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExchangeStatus* New() const final {
    return CreateMaybeMessage<ExchangeStatus>(NULL);
  }

  ExchangeStatus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExchangeStatus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExchangeStatus& from);
  void MergeFrom(const ExchangeStatus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExchangeStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TradingSession session = 10;
  bool has_session() const;
  void clear_session();
  static const int kSessionFieldNumber = 10;
  private:
  const ::TradingSession& _internal_session() const;
  public:
  const ::TradingSession& session() const;
  ::TradingSession* release_session();
  ::TradingSession* mutable_session();
  void set_allocated_session(::TradingSession* session);

  // .SessionStatus status = 20;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 20;
  private:
  const ::SessionStatus& _internal_status() const;
  public:
  const ::SessionStatus& status() const;
  ::SessionStatus* release_status();
  ::SessionStatus* mutable_status();
  void set_allocated_status(::SessionStatus* status);

  // @@protoc_insertion_point(class_scope:ExchangeStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::TradingSession* session_;
  ::SessionStatus* status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActiveContractProduct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ActiveContractProduct) */ {
 public:
  ActiveContractProduct();
  virtual ~ActiveContractProduct();

  ActiveContractProduct(const ActiveContractProduct& from);

  inline ActiveContractProduct& operator=(const ActiveContractProduct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActiveContractProduct(ActiveContractProduct&& from) noexcept
    : ActiveContractProduct() {
    *this = ::std::move(from);
  }

  inline ActiveContractProduct& operator=(ActiveContractProduct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActiveContractProduct& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActiveContractProduct* internal_default_instance() {
    return reinterpret_cast<const ActiveContractProduct*>(
               &_ActiveContractProduct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ActiveContractProduct* other);
  friend void swap(ActiveContractProduct& a, ActiveContractProduct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActiveContractProduct* New() const final {
    return CreateMaybeMessage<ActiveContractProduct>(NULL);
  }

  ActiveContractProduct* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActiveContractProduct>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActiveContractProduct& from);
  void MergeFrom(const ActiveContractProduct& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveContractProduct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Contract contract = 10;
  bool has_contract() const;
  void clear_contract();
  static const int kContractFieldNumber = 10;
  private:
  const ::Contract& _internal_contract() const;
  public:
  const ::Contract& contract() const;
  ::Contract* release_contract();
  ::Contract* mutable_contract();
  void set_allocated_contract(::Contract* contract);

  // .Product product = 20;
  bool has_product() const;
  void clear_product();
  static const int kProductFieldNumber = 20;
  private:
  const ::Product& _internal_product() const;
  public:
  const ::Product& product() const;
  ::Product* release_product();
  ::Product* mutable_product();
  void set_allocated_product(::Product* product);

  // .Schedule schedule = 30;
  bool has_schedule() const;
  void clear_schedule();
  static const int kScheduleFieldNumber = 30;
  private:
  const ::Schedule& _internal_schedule() const;
  public:
  const ::Schedule& schedule() const;
  ::Schedule* release_schedule();
  ::Schedule* mutable_schedule();
  void set_allocated_schedule(::Schedule* schedule);

  // @@protoc_insertion_point(class_scope:ActiveContractProduct)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Contract* contract_;
  ::Product* product_;
  ::Schedule* schedule_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(Position* other);
  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(NULL);
  }

  Position* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // sint32 position = 10;
  void clear_position();
  static const int kPositionFieldNumber = 10;
  ::google::protobuf::int32 position() const;
  void set_position(::google::protobuf::int32 value);

  // uint32 avg_price = 20;
  void clear_avg_price();
  static const int kAvgPriceFieldNumber = 20;
  ::google::protobuf::uint32 avg_price() const;
  void set_avg_price(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 position_;
  ::google::protobuf::uint32 avg_price_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OrderFills : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:OrderFills) */ {
 public:
  OrderFills();
  virtual ~OrderFills();

  OrderFills(const OrderFills& from);

  inline OrderFills& operator=(const OrderFills& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrderFills(OrderFills&& from) noexcept
    : OrderFills() {
    *this = ::std::move(from);
  }

  inline OrderFills& operator=(OrderFills&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const OrderFills& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrderFills* internal_default_instance() {
    return reinterpret_cast<const OrderFills*>(
               &_OrderFills_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(OrderFills* other);
  friend void swap(OrderFills& a, OrderFills& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrderFills* New() const final {
    return CreateMaybeMessage<OrderFills>(NULL);
  }

  OrderFills* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrderFills>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrderFills& from);
  void MergeFrom(const OrderFills& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrderFills* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .FillData fills = 50;
  int fills_size() const;
  void clear_fills();
  static const int kFillsFieldNumber = 50;
  ::FillData* mutable_fills(int index);
  ::google::protobuf::RepeatedPtrField< ::FillData >*
      mutable_fills();
  const ::FillData& fills(int index) const;
  ::FillData* add_fills();
  const ::google::protobuf::RepeatedPtrField< ::FillData >&
      fills() const;

  // .BookOrder order = 10;
  bool has_order() const;
  void clear_order();
  static const int kOrderFieldNumber = 10;
  private:
  const ::BookOrder& _internal_order() const;
  public:
  const ::BookOrder& order() const;
  ::BookOrder* release_order();
  ::BookOrder* mutable_order();
  void set_allocated_order(::BookOrder* order);

  // @@protoc_insertion_point(class_scope:OrderFills)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::FillData > fills_;
  ::BookOrder* order_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AccountState_PositionsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<AccountState_PositionsEntry_DoNotUse, 
    ::std::string, ::Position,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<AccountState_PositionsEntry_DoNotUse, 
    ::std::string, ::Position,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  AccountState_PositionsEntry_DoNotUse();
  AccountState_PositionsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const AccountState_PositionsEntry_DoNotUse& other);
  static const AccountState_PositionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const AccountState_PositionsEntry_DoNotUse*>(&_AccountState_PositionsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class AccountState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:AccountState) */ {
 public:
  AccountState();
  virtual ~AccountState();

  AccountState(const AccountState& from);

  inline AccountState& operator=(const AccountState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountState(AccountState&& from) noexcept
    : AccountState() {
    *this = ::std::move(from);
  }

  inline AccountState& operator=(AccountState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountState& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountState* internal_default_instance() {
    return reinterpret_cast<const AccountState*>(
               &_AccountState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(AccountState* other);
  friend void swap(AccountState& a, AccountState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountState* New() const final {
    return CreateMaybeMessage<AccountState>(NULL);
  }

  AccountState* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AccountState>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AccountState& from);
  void MergeFrom(const AccountState& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .Position> positions = 120;
  int positions_size() const;
  void clear_positions();
  static const int kPositionsFieldNumber = 120;
  const ::google::protobuf::Map< ::std::string, ::Position >&
      positions() const;
  ::google::protobuf::Map< ::std::string, ::Position >*
      mutable_positions();

  // string sidepit_id = 10;
  void clear_sidepit_id();
  static const int kSidepitIdFieldNumber = 10;
  const ::std::string& sidepit_id() const;
  void set_sidepit_id(const ::std::string& value);
  #if LANG_CXX11
  void set_sidepit_id(::std::string&& value);
  #endif
  void set_sidepit_id(const char* value);
  void set_sidepit_id(const char* value, size_t size);
  ::std::string* mutable_sidepit_id();
  ::std::string* release_sidepit_id();
  void set_allocated_sidepit_id(::std::string* sidepit_id);

  // string pubkey = 20;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 20;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const char* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // int64 net_locked = 30;
  void clear_net_locked();
  static const int kNetLockedFieldNumber = 30;
  ::google::protobuf::int64 net_locked() const;
  void set_net_locked(::google::protobuf::int64 value);

  // int64 pending_unlock = 40;
  void clear_pending_unlock();
  static const int kPendingUnlockFieldNumber = 40;
  ::google::protobuf::int64 pending_unlock() const;
  void set_pending_unlock(::google::protobuf::int64 value);

  // int64 realized_pnl = 50;
  void clear_realized_pnl();
  static const int kRealizedPnlFieldNumber = 50;
  ::google::protobuf::int64 realized_pnl() const;
  void set_realized_pnl(::google::protobuf::int64 value);

  // int64 unrealized_pnl = 60;
  void clear_unrealized_pnl();
  static const int kUnrealizedPnlFieldNumber = 60;
  ::google::protobuf::int64 unrealized_pnl() const;
  void set_unrealized_pnl(::google::protobuf::int64 value);

  // int64 margin_required = 80;
  void clear_margin_required();
  static const int kMarginRequiredFieldNumber = 80;
  ::google::protobuf::int64 margin_required() const;
  void set_margin_required(::google::protobuf::int64 value);

  // int64 available_balance = 90;
  void clear_available_balance();
  static const int kAvailableBalanceFieldNumber = 90;
  ::google::protobuf::int64 available_balance() const;
  void set_available_balance(::google::protobuf::int64 value);

  // int64 available_margin = 100;
  void clear_available_margin();
  static const int kAvailableMarginFieldNumber = 100;
  ::google::protobuf::int64 available_margin() const;
  void set_available_margin(::google::protobuf::int64 value);

  // bool is_restricted = 110;
  void clear_is_restricted();
  static const int kIsRestrictedFieldNumber = 110;
  bool is_restricted() const;
  void set_is_restricted(bool value);

  // int32 reduce_only = 112;
  void clear_reduce_only();
  static const int kReduceOnlyFieldNumber = 112;
  ::google::protobuf::int32 reduce_only() const;
  void set_reduce_only(::google::protobuf::int32 value);

  // sint32 carried_position = 130;
  void clear_carried_position();
  static const int kCarriedPositionFieldNumber = 130;
  ::google::protobuf::int32 carried_position() const;
  void set_carried_position(::google::protobuf::int32 value);

  // sint32 new_position = 140;
  void clear_new_position();
  static const int kNewPositionFieldNumber = 140;
  ::google::protobuf::int32 new_position() const;
  void set_new_position(::google::protobuf::int32 value);

  // int32 open_bids = 150;
  void clear_open_bids();
  static const int kOpenBidsFieldNumber = 150;
  ::google::protobuf::int32 open_bids() const;
  void set_open_bids(::google::protobuf::int32 value);

  // int32 open_asks = 160;
  void clear_open_asks();
  static const int kOpenAsksFieldNumber = 160;
  ::google::protobuf::int32 open_asks() const;
  void set_open_asks(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AccountState)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      AccountState_PositionsEntry_DoNotUse,
      ::std::string, ::Position,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > positions_;
  ::google::protobuf::internal::ArenaStringPtr sidepit_id_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::int64 net_locked_;
  ::google::protobuf::int64 pending_unlock_;
  ::google::protobuf::int64 realized_pnl_;
  ::google::protobuf::int64 unrealized_pnl_;
  ::google::protobuf::int64 margin_required_;
  ::google::protobuf::int64 available_balance_;
  ::google::protobuf::int64 available_margin_;
  bool is_restricted_;
  ::google::protobuf::int32 reduce_only_;
  ::google::protobuf::int32 carried_position_;
  ::google::protobuf::int32 new_position_;
  ::google::protobuf::int32 open_bids_;
  ::google::protobuf::int32 open_asks_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BtcLocks : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:BtcLocks) */ {
 public:
  BtcLocks();
  virtual ~BtcLocks();

  BtcLocks(const BtcLocks& from);

  inline BtcLocks& operator=(const BtcLocks& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BtcLocks(BtcLocks&& from) noexcept
    : BtcLocks() {
    *this = ::std::move(from);
  }

  inline BtcLocks& operator=(BtcLocks&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BtcLocks& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BtcLocks* internal_default_instance() {
    return reinterpret_cast<const BtcLocks*>(
               &_BtcLocks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(BtcLocks* other);
  friend void swap(BtcLocks& a, BtcLocks& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BtcLocks* New() const final {
    return CreateMaybeMessage<BtcLocks>(NULL);
  }

  BtcLocks* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BtcLocks>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BtcLocks& from);
  void MergeFrom(const BtcLocks& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BtcLocks* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string txid = 10;
  void clear_txid();
  static const int kTxidFieldNumber = 10;
  const ::std::string& txid() const;
  void set_txid(const ::std::string& value);
  #if LANG_CXX11
  void set_txid(::std::string&& value);
  #endif
  void set_txid(const char* value);
  void set_txid(const char* value, size_t size);
  ::std::string* mutable_txid();
  ::std::string* release_txid();
  void set_allocated_txid(::std::string* txid);

  // string pubkey = 20;
  void clear_pubkey();
  static const int kPubkeyFieldNumber = 20;
  const ::std::string& pubkey() const;
  void set_pubkey(const ::std::string& value);
  #if LANG_CXX11
  void set_pubkey(::std::string&& value);
  #endif
  void set_pubkey(const char* value);
  void set_pubkey(const char* value, size_t size);
  ::std::string* mutable_pubkey();
  ::std::string* release_pubkey();
  void set_allocated_pubkey(::std::string* pubkey);

  // string btc_address = 30;
  void clear_btc_address();
  static const int kBtcAddressFieldNumber = 30;
  const ::std::string& btc_address() const;
  void set_btc_address(const ::std::string& value);
  #if LANG_CXX11
  void set_btc_address(::std::string&& value);
  #endif
  void set_btc_address(const char* value);
  void set_btc_address(const char* value, size_t size);
  ::std::string* mutable_btc_address();
  ::std::string* release_btc_address();
  void set_allocated_btc_address(::std::string* btc_address);

  // bool is_pending = 60;
  void clear_is_pending();
  static const int kIsPendingFieldNumber = 60;
  bool is_pending() const;
  void set_is_pending(bool value);

  // uint64 lock_sats = 40;
  void clear_lock_sats();
  static const int kLockSatsFieldNumber = 40;
  ::google::protobuf::uint64 lock_sats() const;
  void set_lock_sats(::google::protobuf::uint64 value);

  // uint64 unlock_sats = 50;
  void clear_unlock_sats();
  static const int kUnlockSatsFieldNumber = 50;
  ::google::protobuf::uint64 unlock_sats() const;
  void set_unlock_sats(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:BtcLocks)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr txid_;
  ::google::protobuf::internal::ArenaStringPtr pubkey_;
  ::google::protobuf::internal::ArenaStringPtr btc_address_;
  bool is_pending_;
  ::google::protobuf::uint64 lock_sats_;
  ::google::protobuf::uint64 unlock_sats_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:RequestReply) */ {
 public:
  RequestReply();
  virtual ~RequestReply();

  RequestReply(const RequestReply& from);

  inline RequestReply& operator=(const RequestReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestReply(RequestReply&& from) noexcept
    : RequestReply() {
    *this = ::std::move(from);
  }

  inline RequestReply& operator=(RequestReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestReply* internal_default_instance() {
    return reinterpret_cast<const RequestReply*>(
               &_RequestReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(RequestReply* other);
  friend void swap(RequestReply& a, RequestReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestReply* New() const final {
    return CreateMaybeMessage<RequestReply>(NULL);
  }

  RequestReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestReply& from);
  void MergeFrom(const RequestReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string traderid = 10;
  void clear_traderid();
  static const int kTraderidFieldNumber = 10;
  const ::std::string& traderid() const;
  void set_traderid(const ::std::string& value);
  #if LANG_CXX11
  void set_traderid(::std::string&& value);
  #endif
  void set_traderid(const char* value);
  void set_traderid(const char* value, size_t size);
  ::std::string* mutable_traderid();
  ::std::string* release_traderid();
  void set_allocated_traderid(::std::string* traderid);

  // string ticker = 30;
  void clear_ticker();
  static const int kTickerFieldNumber = 30;
  const ::std::string& ticker() const;
  void set_ticker(const ::std::string& value);
  #if LANG_CXX11
  void set_ticker(::std::string&& value);
  #endif
  void set_ticker(const char* value);
  void set_ticker(const char* value, size_t size);
  ::std::string* mutable_ticker();
  ::std::string* release_ticker();
  void set_allocated_ticker(::std::string* ticker);

  // int32 TypeMask = 1;
  void clear_typemask();
  static const int kTypeMaskFieldNumber = 1;
  ::google::protobuf::int32 typemask() const;
  void set_typemask(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RequestReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr traderid_;
  ::google::protobuf::internal::ArenaStringPtr ticker_;
  ::google::protobuf::int32 typemask_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReplyRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ReplyRequest) */ {
 public:
  ReplyRequest();
  virtual ~ReplyRequest();

  ReplyRequest(const ReplyRequest& from);

  inline ReplyRequest& operator=(const ReplyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReplyRequest(ReplyRequest&& from) noexcept
    : ReplyRequest() {
    *this = ::std::move(from);
  }

  inline ReplyRequest& operator=(ReplyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReplyRequest* internal_default_instance() {
    return reinterpret_cast<const ReplyRequest*>(
               &_ReplyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ReplyRequest* other);
  friend void swap(ReplyRequest& a, ReplyRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReplyRequest* New() const final {
    return CreateMaybeMessage<ReplyRequest>(NULL);
  }

  ReplyRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReplyRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReplyRequest& from);
  void MergeFrom(const ReplyRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .TraderPositionOrders trader_positions = 20;
  bool has_trader_positions() const;
  void clear_trader_positions();
  static const int kTraderPositionsFieldNumber = 20;
  private:
  const ::TraderPositionOrders& _internal_trader_positions() const;
  public:
  const ::TraderPositionOrders& trader_positions() const;
  ::TraderPositionOrders* release_trader_positions();
  ::TraderPositionOrders* mutable_trader_positions();
  void set_allocated_trader_positions(::TraderPositionOrders* trader_positions);

  // .ActiveProduct active_product = 30;
  bool has_active_product() const;
  void clear_active_product();
  static const int kActiveProductFieldNumber = 30;
  private:
  const ::ActiveProduct& _internal_active_product() const;
  public:
  const ::ActiveProduct& active_product() const;
  ::ActiveProduct* release_active_product();
  ::ActiveProduct* mutable_active_product();
  void set_allocated_active_product(::ActiveProduct* active_product);

  // .MarketData market_data = 40;
  bool has_market_data() const;
  void clear_market_data();
  static const int kMarketDataFieldNumber = 40;
  private:
  const ::MarketData& _internal_market_data() const;
  public:
  const ::MarketData& market_data() const;
  ::MarketData* release_market_data();
  ::MarketData* mutable_market_data();
  void set_allocated_market_data(::MarketData* market_data);

  // int32 TypeMask = 10;
  void clear_typemask();
  static const int kTypeMaskFieldNumber = 10;
  ::google::protobuf::int32 typemask() const;
  void set_typemask(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ReplyRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::TraderPositionOrders* trader_positions_;
  ::ActiveProduct* active_product_;
  ::MarketData* market_data_;
  ::google::protobuf::int32 typemask_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TraderPositionOrders_OrderfillsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<TraderPositionOrders_OrderfillsEntry_DoNotUse, 
    ::std::string, ::OrderFills,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<TraderPositionOrders_OrderfillsEntry_DoNotUse, 
    ::std::string, ::OrderFills,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  TraderPositionOrders_OrderfillsEntry_DoNotUse();
  TraderPositionOrders_OrderfillsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TraderPositionOrders_OrderfillsEntry_DoNotUse& other);
  static const TraderPositionOrders_OrderfillsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TraderPositionOrders_OrderfillsEntry_DoNotUse*>(&_TraderPositionOrders_OrderfillsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class TraderPositionOrders : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TraderPositionOrders) */ {
 public:
  TraderPositionOrders();
  virtual ~TraderPositionOrders();

  TraderPositionOrders(const TraderPositionOrders& from);

  inline TraderPositionOrders& operator=(const TraderPositionOrders& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TraderPositionOrders(TraderPositionOrders&& from) noexcept
    : TraderPositionOrders() {
    *this = ::std::move(from);
  }

  inline TraderPositionOrders& operator=(TraderPositionOrders&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TraderPositionOrders& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TraderPositionOrders* internal_default_instance() {
    return reinterpret_cast<const TraderPositionOrders*>(
               &_TraderPositionOrders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(TraderPositionOrders* other);
  friend void swap(TraderPositionOrders& a, TraderPositionOrders& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TraderPositionOrders* New() const final {
    return CreateMaybeMessage<TraderPositionOrders>(NULL);
  }

  TraderPositionOrders* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TraderPositionOrders>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TraderPositionOrders& from);
  void MergeFrom(const TraderPositionOrders& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TraderPositionOrders* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, .OrderFills> orderfills = 40;
  int orderfills_size() const;
  void clear_orderfills();
  static const int kOrderfillsFieldNumber = 40;
  const ::google::protobuf::Map< ::std::string, ::OrderFills >&
      orderfills() const;
  ::google::protobuf::Map< ::std::string, ::OrderFills >*
      mutable_orderfills();

  // repeated .BtcLocks locks = 60;
  int locks_size() const;
  void clear_locks();
  static const int kLocksFieldNumber = 60;
  ::BtcLocks* mutable_locks(int index);
  ::google::protobuf::RepeatedPtrField< ::BtcLocks >*
      mutable_locks();
  const ::BtcLocks& locks(int index) const;
  ::BtcLocks* add_locks();
  const ::google::protobuf::RepeatedPtrField< ::BtcLocks >&
      locks() const;

  // string traderid = 10;
  void clear_traderid();
  static const int kTraderidFieldNumber = 10;
  const ::std::string& traderid() const;
  void set_traderid(const ::std::string& value);
  #if LANG_CXX11
  void set_traderid(::std::string&& value);
  #endif
  void set_traderid(const char* value);
  void set_traderid(const char* value, size_t size);
  ::std::string* mutable_traderid();
  ::std::string* release_traderid();
  void set_allocated_traderid(::std::string* traderid);

  // string symbol = 20;
  void clear_symbol();
  static const int kSymbolFieldNumber = 20;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  #if LANG_CXX11
  void set_symbol(::std::string&& value);
  #endif
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // .AccountState accountstate = 50;
  bool has_accountstate() const;
  void clear_accountstate();
  static const int kAccountstateFieldNumber = 50;
  private:
  const ::AccountState& _internal_accountstate() const;
  public:
  const ::AccountState& accountstate() const;
  ::AccountState* release_accountstate();
  ::AccountState* mutable_accountstate();
  void set_allocated_accountstate(::AccountState* accountstate);

  // @@protoc_insertion_point(class_scope:TraderPositionOrders)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      TraderPositionOrders_OrderfillsEntry_DoNotUse,
      ::std::string, ::OrderFills,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > orderfills_;
  ::google::protobuf::RepeatedPtrField< ::BtcLocks > locks_;
  ::google::protobuf::internal::ArenaStringPtr traderid_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  ::AccountState* accountstate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ActiveProduct : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ActiveProduct) */ {
 public:
  ActiveProduct();
  virtual ~ActiveProduct();

  ActiveProduct(const ActiveProduct& from);

  inline ActiveProduct& operator=(const ActiveProduct& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ActiveProduct(ActiveProduct&& from) noexcept
    : ActiveProduct() {
    *this = ::std::move(from);
  }

  inline ActiveProduct& operator=(ActiveProduct&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ActiveProduct& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ActiveProduct* internal_default_instance() {
    return reinterpret_cast<const ActiveProduct*>(
               &_ActiveProduct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(ActiveProduct* other);
  friend void swap(ActiveProduct& a, ActiveProduct& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ActiveProduct* New() const final {
    return CreateMaybeMessage<ActiveProduct>(NULL);
  }

  ActiveProduct* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ActiveProduct>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ActiveProduct& from);
  void MergeFrom(const ActiveProduct& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ActiveProduct* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .ActiveContractProduct active_contract_product = 10;
  bool has_active_contract_product() const;
  void clear_active_contract_product();
  static const int kActiveContractProductFieldNumber = 10;
  private:
  const ::ActiveContractProduct& _internal_active_contract_product() const;
  public:
  const ::ActiveContractProduct& active_contract_product() const;
  ::ActiveContractProduct* release_active_contract_product();
  ::ActiveContractProduct* mutable_active_contract_product();
  void set_allocated_active_contract_product(::ActiveContractProduct* active_contract_product);

  // .ExchangeStatus exchange_status = 20;
  bool has_exchange_status() const;
  void clear_exchange_status();
  static const int kExchangeStatusFieldNumber = 20;
  private:
  const ::ExchangeStatus& _internal_exchange_status() const;
  public:
  const ::ExchangeStatus& exchange_status() const;
  ::ExchangeStatus* release_exchange_status();
  ::ExchangeStatus* mutable_exchange_status();
  void set_allocated_exchange_status(::ExchangeStatus* exchange_status);

  // .ContractBar contractbar = 30;
  bool has_contractbar() const;
  void clear_contractbar();
  static const int kContractbarFieldNumber = 30;
  private:
  const ::ContractBar& _internal_contractbar() const;
  public:
  const ::ContractBar& contractbar() const;
  ::ContractBar* release_contractbar();
  ::ContractBar* mutable_contractbar();
  void set_allocated_contractbar(::ContractBar* contractbar);

  // @@protoc_insertion_point(class_scope:ActiveProduct)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::ActiveContractProduct* active_contract_product_;
  ::ExchangeStatus* exchange_status_;
  ::ContractBar* contractbar_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_sidepit_5fapi_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Transaction

// int32 version = 1;
inline void Transaction::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 Transaction::version() const {
  // @@protoc_insertion_point(field_get:Transaction.version)
  return version_;
}
inline void Transaction::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:Transaction.version)
}

// uint64 timestamp = 10;
inline void Transaction::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Transaction::timestamp() const {
  // @@protoc_insertion_point(field_get:Transaction.timestamp)
  return timestamp_;
}
inline void Transaction::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:Transaction.timestamp)
}

// .NewOrder new_order = 20;
inline bool Transaction::has_new_order() const {
  return tx_case() == kNewOrder;
}
inline void Transaction::set_has_new_order() {
  _oneof_case_[0] = kNewOrder;
}
inline void Transaction::clear_new_order() {
  if (has_new_order()) {
    delete tx_.new_order_;
    clear_has_tx();
  }
}
inline const ::NewOrder& Transaction::_internal_new_order() const {
  return *tx_.new_order_;
}
inline ::NewOrder* Transaction::release_new_order() {
  // @@protoc_insertion_point(field_release:Transaction.new_order)
  if (has_new_order()) {
    clear_has_tx();
      ::NewOrder* temp = tx_.new_order_;
    tx_.new_order_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::NewOrder& Transaction::new_order() const {
  // @@protoc_insertion_point(field_get:Transaction.new_order)
  return has_new_order()
      ? *tx_.new_order_
      : *reinterpret_cast< ::NewOrder*>(&::_NewOrder_default_instance_);
}
inline ::NewOrder* Transaction::mutable_new_order() {
  if (!has_new_order()) {
    clear_tx();
    set_has_new_order();
    tx_.new_order_ = CreateMaybeMessage< ::NewOrder >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Transaction.new_order)
  return tx_.new_order_;
}

// string cancel_orderid = 30;
inline bool Transaction::has_cancel_orderid() const {
  return tx_case() == kCancelOrderid;
}
inline void Transaction::set_has_cancel_orderid() {
  _oneof_case_[0] = kCancelOrderid;
}
inline void Transaction::clear_cancel_orderid() {
  if (has_cancel_orderid()) {
    tx_.cancel_orderid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_tx();
  }
}
inline const ::std::string& Transaction::cancel_orderid() const {
  // @@protoc_insertion_point(field_get:Transaction.cancel_orderid)
  if (has_cancel_orderid()) {
    return tx_.cancel_orderid_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void Transaction::set_cancel_orderid(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Transaction.cancel_orderid)
  if (!has_cancel_orderid()) {
    clear_tx();
    set_has_cancel_orderid();
    tx_.cancel_orderid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  tx_.cancel_orderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Transaction.cancel_orderid)
}
#if LANG_CXX11
inline void Transaction::set_cancel_orderid(::std::string&& value) {
  // @@protoc_insertion_point(field_set:Transaction.cancel_orderid)
  if (!has_cancel_orderid()) {
    clear_tx();
    set_has_cancel_orderid();
    tx_.cancel_orderid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  tx_.cancel_orderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Transaction.cancel_orderid)
}
#endif
inline void Transaction::set_cancel_orderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_cancel_orderid()) {
    clear_tx();
    set_has_cancel_orderid();
    tx_.cancel_orderid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  tx_.cancel_orderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Transaction.cancel_orderid)
}
inline void Transaction::set_cancel_orderid(const char* value, size_t size) {
  if (!has_cancel_orderid()) {
    clear_tx();
    set_has_cancel_orderid();
    tx_.cancel_orderid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  tx_.cancel_orderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Transaction.cancel_orderid)
}
inline ::std::string* Transaction::mutable_cancel_orderid() {
  if (!has_cancel_orderid()) {
    clear_tx();
    set_has_cancel_orderid();
    tx_.cancel_orderid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:Transaction.cancel_orderid)
  return tx_.cancel_orderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_cancel_orderid() {
  // @@protoc_insertion_point(field_release:Transaction.cancel_orderid)
  if (has_cancel_orderid()) {
    clear_has_tx();
    return tx_.cancel_orderid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void Transaction::set_allocated_cancel_orderid(::std::string* cancel_orderid) {
  if (!has_cancel_orderid()) {
    tx_.cancel_orderid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_tx();
  if (cancel_orderid != NULL) {
    set_has_cancel_orderid();
    tx_.cancel_orderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cancel_orderid);
  }
  // @@protoc_insertion_point(field_set_allocated:Transaction.cancel_orderid)
}

// .AuctionBid auction_bid = 40;
inline bool Transaction::has_auction_bid() const {
  return tx_case() == kAuctionBid;
}
inline void Transaction::set_has_auction_bid() {
  _oneof_case_[0] = kAuctionBid;
}
inline void Transaction::clear_auction_bid() {
  if (has_auction_bid()) {
    delete tx_.auction_bid_;
    clear_has_tx();
  }
}
inline const ::AuctionBid& Transaction::_internal_auction_bid() const {
  return *tx_.auction_bid_;
}
inline ::AuctionBid* Transaction::release_auction_bid() {
  // @@protoc_insertion_point(field_release:Transaction.auction_bid)
  if (has_auction_bid()) {
    clear_has_tx();
      ::AuctionBid* temp = tx_.auction_bid_;
    tx_.auction_bid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::AuctionBid& Transaction::auction_bid() const {
  // @@protoc_insertion_point(field_get:Transaction.auction_bid)
  return has_auction_bid()
      ? *tx_.auction_bid_
      : *reinterpret_cast< ::AuctionBid*>(&::_AuctionBid_default_instance_);
}
inline ::AuctionBid* Transaction::mutable_auction_bid() {
  if (!has_auction_bid()) {
    clear_tx();
    set_has_auction_bid();
    tx_.auction_bid_ = CreateMaybeMessage< ::AuctionBid >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Transaction.auction_bid)
  return tx_.auction_bid_;
}

// .UnlockRequest unlock_req = 50;
inline bool Transaction::has_unlock_req() const {
  return tx_case() == kUnlockReq;
}
inline void Transaction::set_has_unlock_req() {
  _oneof_case_[0] = kUnlockReq;
}
inline void Transaction::clear_unlock_req() {
  if (has_unlock_req()) {
    delete tx_.unlock_req_;
    clear_has_tx();
  }
}
inline const ::UnlockRequest& Transaction::_internal_unlock_req() const {
  return *tx_.unlock_req_;
}
inline ::UnlockRequest* Transaction::release_unlock_req() {
  // @@protoc_insertion_point(field_release:Transaction.unlock_req)
  if (has_unlock_req()) {
    clear_has_tx();
      ::UnlockRequest* temp = tx_.unlock_req_;
    tx_.unlock_req_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::UnlockRequest& Transaction::unlock_req() const {
  // @@protoc_insertion_point(field_get:Transaction.unlock_req)
  return has_unlock_req()
      ? *tx_.unlock_req_
      : *reinterpret_cast< ::UnlockRequest*>(&::_UnlockRequest_default_instance_);
}
inline ::UnlockRequest* Transaction::mutable_unlock_req() {
  if (!has_unlock_req()) {
    clear_tx();
    set_has_unlock_req();
    tx_.unlock_req_ = CreateMaybeMessage< ::UnlockRequest >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:Transaction.unlock_req)
  return tx_.unlock_req_;
}

// string sidepit_id = 101;
inline void Transaction::clear_sidepit_id() {
  sidepit_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Transaction::sidepit_id() const {
  // @@protoc_insertion_point(field_get:Transaction.sidepit_id)
  return sidepit_id_.GetNoArena();
}
inline void Transaction::set_sidepit_id(const ::std::string& value) {
  
  sidepit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Transaction.sidepit_id)
}
#if LANG_CXX11
inline void Transaction::set_sidepit_id(::std::string&& value) {
  
  sidepit_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Transaction.sidepit_id)
}
#endif
inline void Transaction::set_sidepit_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sidepit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Transaction.sidepit_id)
}
inline void Transaction::set_sidepit_id(const char* value, size_t size) {
  
  sidepit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Transaction.sidepit_id)
}
inline ::std::string* Transaction::mutable_sidepit_id() {
  
  // @@protoc_insertion_point(field_mutable:Transaction.sidepit_id)
  return sidepit_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Transaction::release_sidepit_id() {
  // @@protoc_insertion_point(field_release:Transaction.sidepit_id)
  
  return sidepit_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Transaction::set_allocated_sidepit_id(::std::string* sidepit_id) {
  if (sidepit_id != NULL) {
    
  } else {
    
  }
  sidepit_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sidepit_id);
  // @@protoc_insertion_point(field_set_allocated:Transaction.sidepit_id)
}

inline bool Transaction::has_tx() const {
  return tx_case() != TX_NOT_SET;
}
inline void Transaction::clear_has_tx() {
  _oneof_case_[0] = TX_NOT_SET;
}
inline Transaction::TxCase Transaction::tx_case() const {
  return Transaction::TxCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// SignedTransaction

// int32 signature_version = 2;
inline void SignedTransaction::clear_signature_version() {
  signature_version_ = 0;
}
inline ::google::protobuf::int32 SignedTransaction::signature_version() const {
  // @@protoc_insertion_point(field_get:SignedTransaction.signature_version)
  return signature_version_;
}
inline void SignedTransaction::set_signature_version(::google::protobuf::int32 value) {
  
  signature_version_ = value;
  // @@protoc_insertion_point(field_set:SignedTransaction.signature_version)
}

// .Transaction transaction = 11;
inline bool SignedTransaction::has_transaction() const {
  return this != internal_default_instance() && transaction_ != NULL;
}
inline void SignedTransaction::clear_transaction() {
  if (GetArenaNoVirtual() == NULL && transaction_ != NULL) {
    delete transaction_;
  }
  transaction_ = NULL;
}
inline const ::Transaction& SignedTransaction::_internal_transaction() const {
  return *transaction_;
}
inline const ::Transaction& SignedTransaction::transaction() const {
  const ::Transaction* p = transaction_;
  // @@protoc_insertion_point(field_get:SignedTransaction.transaction)
  return p != NULL ? *p : *reinterpret_cast<const ::Transaction*>(
      &::_Transaction_default_instance_);
}
inline ::Transaction* SignedTransaction::release_transaction() {
  // @@protoc_insertion_point(field_release:SignedTransaction.transaction)
  
  ::Transaction* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline ::Transaction* SignedTransaction::mutable_transaction() {
  
  if (transaction_ == NULL) {
    auto* p = CreateMaybeMessage<::Transaction>(GetArenaNoVirtual());
    transaction_ = p;
  }
  // @@protoc_insertion_point(field_mutable:SignedTransaction.transaction)
  return transaction_;
}
inline void SignedTransaction::set_allocated_transaction(::Transaction* transaction) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete transaction_;
  }
  if (transaction) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      transaction = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:SignedTransaction.transaction)
}

// string tx_digest = 21;
inline void SignedTransaction::clear_tx_digest() {
  tx_digest_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignedTransaction::tx_digest() const {
  // @@protoc_insertion_point(field_get:SignedTransaction.tx_digest)
  return tx_digest_.GetNoArena();
}
inline void SignedTransaction::set_tx_digest(const ::std::string& value) {
  
  tx_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignedTransaction.tx_digest)
}
#if LANG_CXX11
inline void SignedTransaction::set_tx_digest(::std::string&& value) {
  
  tx_digest_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SignedTransaction.tx_digest)
}
#endif
inline void SignedTransaction::set_tx_digest(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tx_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignedTransaction.tx_digest)
}
inline void SignedTransaction::set_tx_digest(const char* value, size_t size) {
  
  tx_digest_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignedTransaction.tx_digest)
}
inline ::std::string* SignedTransaction::mutable_tx_digest() {
  
  // @@protoc_insertion_point(field_mutable:SignedTransaction.tx_digest)
  return tx_digest_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedTransaction::release_tx_digest() {
  // @@protoc_insertion_point(field_release:SignedTransaction.tx_digest)
  
  return tx_digest_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedTransaction::set_allocated_tx_digest(::std::string* tx_digest) {
  if (tx_digest != NULL) {
    
  } else {
    
  }
  tx_digest_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tx_digest);
  // @@protoc_insertion_point(field_set_allocated:SignedTransaction.tx_digest)
}

// string pubkey = 31;
inline void SignedTransaction::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignedTransaction::pubkey() const {
  // @@protoc_insertion_point(field_get:SignedTransaction.pubkey)
  return pubkey_.GetNoArena();
}
inline void SignedTransaction::set_pubkey(const ::std::string& value) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignedTransaction.pubkey)
}
#if LANG_CXX11
inline void SignedTransaction::set_pubkey(::std::string&& value) {
  
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SignedTransaction.pubkey)
}
#endif
inline void SignedTransaction::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignedTransaction.pubkey)
}
inline void SignedTransaction::set_pubkey(const char* value, size_t size) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignedTransaction.pubkey)
}
inline ::std::string* SignedTransaction::mutable_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:SignedTransaction.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedTransaction::release_pubkey() {
  // @@protoc_insertion_point(field_release:SignedTransaction.pubkey)
  
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedTransaction::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    
  } else {
    
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:SignedTransaction.pubkey)
}

// string signature = 111;
inline void SignedTransaction::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SignedTransaction::signature() const {
  // @@protoc_insertion_point(field_get:SignedTransaction.signature)
  return signature_.GetNoArena();
}
inline void SignedTransaction::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SignedTransaction.signature)
}
#if LANG_CXX11
inline void SignedTransaction::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SignedTransaction.signature)
}
#endif
inline void SignedTransaction::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SignedTransaction.signature)
}
inline void SignedTransaction::set_signature(const char* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SignedTransaction.signature)
}
inline ::std::string* SignedTransaction::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:SignedTransaction.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SignedTransaction::release_signature() {
  // @@protoc_insertion_point(field_release:SignedTransaction.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SignedTransaction::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:SignedTransaction.signature)
}

// -------------------------------------------------------------------

// NewOrder

// sint32 side = 11;
inline void NewOrder::clear_side() {
  side_ = 0;
}
inline ::google::protobuf::int32 NewOrder::side() const {
  // @@protoc_insertion_point(field_get:NewOrder.side)
  return side_;
}
inline void NewOrder::set_side(::google::protobuf::int32 value) {
  
  side_ = value;
  // @@protoc_insertion_point(field_set:NewOrder.side)
}

// int32 size = 20;
inline void NewOrder::clear_size() {
  size_ = 0;
}
inline ::google::protobuf::int32 NewOrder::size() const {
  // @@protoc_insertion_point(field_get:NewOrder.size)
  return size_;
}
inline void NewOrder::set_size(::google::protobuf::int32 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:NewOrder.size)
}

// int32 price = 30;
inline void NewOrder::clear_price() {
  price_ = 0;
}
inline ::google::protobuf::int32 NewOrder::price() const {
  // @@protoc_insertion_point(field_get:NewOrder.price)
  return price_;
}
inline void NewOrder::set_price(::google::protobuf::int32 value) {
  
  price_ = value;
  // @@protoc_insertion_point(field_set:NewOrder.price)
}

// string ticker = 40;
inline void NewOrder::clear_ticker() {
  ticker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NewOrder::ticker() const {
  // @@protoc_insertion_point(field_get:NewOrder.ticker)
  return ticker_.GetNoArena();
}
inline void NewOrder::set_ticker(const ::std::string& value) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:NewOrder.ticker)
}
#if LANG_CXX11
inline void NewOrder::set_ticker(::std::string&& value) {
  
  ticker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:NewOrder.ticker)
}
#endif
inline void NewOrder::set_ticker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:NewOrder.ticker)
}
inline void NewOrder::set_ticker(const char* value, size_t size) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:NewOrder.ticker)
}
inline ::std::string* NewOrder::mutable_ticker() {
  
  // @@protoc_insertion_point(field_mutable:NewOrder.ticker)
  return ticker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NewOrder::release_ticker() {
  // @@protoc_insertion_point(field_release:NewOrder.ticker)
  
  return ticker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NewOrder::set_allocated_ticker(::std::string* ticker) {
  if (ticker != NULL) {
    
  } else {
    
  }
  ticker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticker);
  // @@protoc_insertion_point(field_set_allocated:NewOrder.ticker)
}

// -------------------------------------------------------------------

// AuctionBid

// uint64 epoch = 10;
inline void AuctionBid::clear_epoch() {
  epoch_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 AuctionBid::epoch() const {
  // @@protoc_insertion_point(field_get:AuctionBid.epoch)
  return epoch_;
}
inline void AuctionBid::set_epoch(::google::protobuf::uint64 value) {
  
  epoch_ = value;
  // @@protoc_insertion_point(field_set:AuctionBid.epoch)
}

// string hash = 20;
inline void AuctionBid::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuctionBid::hash() const {
  // @@protoc_insertion_point(field_get:AuctionBid.hash)
  return hash_.GetNoArena();
}
inline void AuctionBid::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuctionBid.hash)
}
#if LANG_CXX11
inline void AuctionBid::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AuctionBid.hash)
}
#endif
inline void AuctionBid::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuctionBid.hash)
}
inline void AuctionBid::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuctionBid.hash)
}
inline ::std::string* AuctionBid::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:AuctionBid.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuctionBid::release_hash() {
  // @@protoc_insertion_point(field_release:AuctionBid.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuctionBid::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:AuctionBid.hash)
}

// string ordering_salt = 30;
inline void AuctionBid::clear_ordering_salt() {
  ordering_salt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AuctionBid::ordering_salt() const {
  // @@protoc_insertion_point(field_get:AuctionBid.ordering_salt)
  return ordering_salt_.GetNoArena();
}
inline void AuctionBid::set_ordering_salt(const ::std::string& value) {
  
  ordering_salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AuctionBid.ordering_salt)
}
#if LANG_CXX11
inline void AuctionBid::set_ordering_salt(::std::string&& value) {
  
  ordering_salt_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AuctionBid.ordering_salt)
}
#endif
inline void AuctionBid::set_ordering_salt(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ordering_salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AuctionBid.ordering_salt)
}
inline void AuctionBid::set_ordering_salt(const char* value, size_t size) {
  
  ordering_salt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AuctionBid.ordering_salt)
}
inline ::std::string* AuctionBid::mutable_ordering_salt() {
  
  // @@protoc_insertion_point(field_mutable:AuctionBid.ordering_salt)
  return ordering_salt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AuctionBid::release_ordering_salt() {
  // @@protoc_insertion_point(field_release:AuctionBid.ordering_salt)
  
  return ordering_salt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AuctionBid::set_allocated_ordering_salt(::std::string* ordering_salt) {
  if (ordering_salt != NULL) {
    
  } else {
    
  }
  ordering_salt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ordering_salt);
  // @@protoc_insertion_point(field_set_allocated:AuctionBid.ordering_salt)
}

// int32 bid = 40;
inline void AuctionBid::clear_bid() {
  bid_ = 0;
}
inline ::google::protobuf::int32 AuctionBid::bid() const {
  // @@protoc_insertion_point(field_get:AuctionBid.bid)
  return bid_;
}
inline void AuctionBid::set_bid(::google::protobuf::int32 value) {
  
  bid_ = value;
  // @@protoc_insertion_point(field_set:AuctionBid.bid)
}

// -------------------------------------------------------------------

// UnlockRequest

// .UnlockRequest.AmountType minmax = 20;
inline void UnlockRequest::clear_minmax() {
  minmax_ = 0;
}
inline ::UnlockRequest_AmountType UnlockRequest::minmax() const {
  // @@protoc_insertion_point(field_get:UnlockRequest.minmax)
  return static_cast< ::UnlockRequest_AmountType >(minmax_);
}
inline void UnlockRequest::set_minmax(::UnlockRequest_AmountType value) {
  
  minmax_ = value;
  // @@protoc_insertion_point(field_set:UnlockRequest.minmax)
}

// uint64 explicit_amount = 30;
inline void UnlockRequest::clear_explicit_amount() {
  explicit_amount_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 UnlockRequest::explicit_amount() const {
  // @@protoc_insertion_point(field_get:UnlockRequest.explicit_amount)
  return explicit_amount_;
}
inline void UnlockRequest::set_explicit_amount(::google::protobuf::uint64 value) {
  
  explicit_amount_ = value;
  // @@protoc_insertion_point(field_set:UnlockRequest.explicit_amount)
}

// -------------------------------------------------------------------

// EpochEvent

// uint64 epoch = 10;
inline void EpochEvent::clear_epoch() {
  epoch_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 EpochEvent::epoch() const {
  // @@protoc_insertion_point(field_get:EpochEvent.epoch)
  return epoch_;
}
inline void EpochEvent::set_epoch(::google::protobuf::uint64 value) {
  
  epoch_ = value;
  // @@protoc_insertion_point(field_set:EpochEvent.epoch)
}

// string hash = 20;
inline void EpochEvent::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EpochEvent::hash() const {
  // @@protoc_insertion_point(field_get:EpochEvent.hash)
  return hash_.GetNoArena();
}
inline void EpochEvent::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EpochEvent.hash)
}
#if LANG_CXX11
inline void EpochEvent::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EpochEvent.hash)
}
#endif
inline void EpochEvent::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EpochEvent.hash)
}
inline void EpochEvent::set_hash(const char* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EpochEvent.hash)
}
inline ::std::string* EpochEvent::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:EpochEvent.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EpochEvent::release_hash() {
  // @@protoc_insertion_point(field_release:EpochEvent.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EpochEvent::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:EpochEvent.hash)
}

// string id = 100;
inline void EpochEvent::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EpochEvent::id() const {
  // @@protoc_insertion_point(field_get:EpochEvent.id)
  return id_.GetNoArena();
}
inline void EpochEvent::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EpochEvent.id)
}
#if LANG_CXX11
inline void EpochEvent::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EpochEvent.id)
}
#endif
inline void EpochEvent::set_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EpochEvent.id)
}
inline void EpochEvent::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EpochEvent.id)
}
inline ::std::string* EpochEvent::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:EpochEvent.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EpochEvent::release_id() {
  // @@protoc_insertion_point(field_release:EpochEvent.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EpochEvent::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:EpochEvent.id)
}

// bytes signature = 110;
inline void EpochEvent::clear_signature() {
  signature_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EpochEvent::signature() const {
  // @@protoc_insertion_point(field_get:EpochEvent.signature)
  return signature_.GetNoArena();
}
inline void EpochEvent::set_signature(const ::std::string& value) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EpochEvent.signature)
}
#if LANG_CXX11
inline void EpochEvent::set_signature(::std::string&& value) {
  
  signature_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EpochEvent.signature)
}
#endif
inline void EpochEvent::set_signature(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EpochEvent.signature)
}
inline void EpochEvent::set_signature(const void* value, size_t size) {
  
  signature_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EpochEvent.signature)
}
inline ::std::string* EpochEvent::mutable_signature() {
  
  // @@protoc_insertion_point(field_mutable:EpochEvent.signature)
  return signature_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EpochEvent::release_signature() {
  // @@protoc_insertion_point(field_release:EpochEvent.signature)
  
  return signature_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EpochEvent::set_allocated_signature(::std::string* signature) {
  if (signature != NULL) {
    
  } else {
    
  }
  signature_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), signature);
  // @@protoc_insertion_point(field_set_allocated:EpochEvent.signature)
}

// -------------------------------------------------------------------

// ExchangeEvent

// .ExchangeState state = 10;
inline void ExchangeEvent::clear_state() {
  state_ = 0;
}
inline ::ExchangeState ExchangeEvent::state() const {
  // @@protoc_insertion_point(field_get:ExchangeEvent.state)
  return static_cast< ::ExchangeState >(state_);
}
inline void ExchangeEvent::set_state(::ExchangeState value) {
  
  state_ = value;
  // @@protoc_insertion_point(field_set:ExchangeEvent.state)
}

// -------------------------------------------------------------------

// TxBlockStream

// uint64 epoch = 10;
inline void TxBlockStream::clear_epoch() {
  epoch_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TxBlockStream::epoch() const {
  // @@protoc_insertion_point(field_get:TxBlockStream.epoch)
  return epoch_;
}
inline void TxBlockStream::set_epoch(::google::protobuf::uint64 value) {
  
  epoch_ = value;
  // @@protoc_insertion_point(field_set:TxBlockStream.epoch)
}

// .ExchangeState estate = 20;
inline void TxBlockStream::clear_estate() {
  estate_ = 0;
}
inline ::ExchangeState TxBlockStream::estate() const {
  // @@protoc_insertion_point(field_get:TxBlockStream.estate)
  return static_cast< ::ExchangeState >(estate_);
}
inline void TxBlockStream::set_estate(::ExchangeState value) {
  
  estate_ = value;
  // @@protoc_insertion_point(field_set:TxBlockStream.estate)
}

// .EpochEvent epoch_event = 25;
inline bool TxBlockStream::has_epoch_event() const {
  return txepoch_case() == kEpochEvent;
}
inline void TxBlockStream::set_has_epoch_event() {
  _oneof_case_[0] = kEpochEvent;
}
inline void TxBlockStream::clear_epoch_event() {
  if (has_epoch_event()) {
    delete txepoch_.epoch_event_;
    clear_has_txepoch();
  }
}
inline const ::EpochEvent& TxBlockStream::_internal_epoch_event() const {
  return *txepoch_.epoch_event_;
}
inline ::EpochEvent* TxBlockStream::release_epoch_event() {
  // @@protoc_insertion_point(field_release:TxBlockStream.epoch_event)
  if (has_epoch_event()) {
    clear_has_txepoch();
      ::EpochEvent* temp = txepoch_.epoch_event_;
    txepoch_.epoch_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::EpochEvent& TxBlockStream::epoch_event() const {
  // @@protoc_insertion_point(field_get:TxBlockStream.epoch_event)
  return has_epoch_event()
      ? *txepoch_.epoch_event_
      : *reinterpret_cast< ::EpochEvent*>(&::_EpochEvent_default_instance_);
}
inline ::EpochEvent* TxBlockStream::mutable_epoch_event() {
  if (!has_epoch_event()) {
    clear_txepoch();
    set_has_epoch_event();
    txepoch_.epoch_event_ = CreateMaybeMessage< ::EpochEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TxBlockStream.epoch_event)
  return txepoch_.epoch_event_;
}

// .SignedTransaction stx = 31;
inline bool TxBlockStream::has_stx() const {
  return txepoch_case() == kStx;
}
inline void TxBlockStream::set_has_stx() {
  _oneof_case_[0] = kStx;
}
inline void TxBlockStream::clear_stx() {
  if (has_stx()) {
    delete txepoch_.stx_;
    clear_has_txepoch();
  }
}
inline const ::SignedTransaction& TxBlockStream::_internal_stx() const {
  return *txepoch_.stx_;
}
inline ::SignedTransaction* TxBlockStream::release_stx() {
  // @@protoc_insertion_point(field_release:TxBlockStream.stx)
  if (has_stx()) {
    clear_has_txepoch();
      ::SignedTransaction* temp = txepoch_.stx_;
    txepoch_.stx_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::SignedTransaction& TxBlockStream::stx() const {
  // @@protoc_insertion_point(field_get:TxBlockStream.stx)
  return has_stx()
      ? *txepoch_.stx_
      : *reinterpret_cast< ::SignedTransaction*>(&::_SignedTransaction_default_instance_);
}
inline ::SignedTransaction* TxBlockStream::mutable_stx() {
  if (!has_stx()) {
    clear_txepoch();
    set_has_stx();
    txepoch_.stx_ = CreateMaybeMessage< ::SignedTransaction >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TxBlockStream.stx)
  return txepoch_.stx_;
}

// .ExchangeEvent exchange_event = 40;
inline bool TxBlockStream::has_exchange_event() const {
  return txepoch_case() == kExchangeEvent;
}
inline void TxBlockStream::set_has_exchange_event() {
  _oneof_case_[0] = kExchangeEvent;
}
inline void TxBlockStream::clear_exchange_event() {
  if (has_exchange_event()) {
    delete txepoch_.exchange_event_;
    clear_has_txepoch();
  }
}
inline const ::ExchangeEvent& TxBlockStream::_internal_exchange_event() const {
  return *txepoch_.exchange_event_;
}
inline ::ExchangeEvent* TxBlockStream::release_exchange_event() {
  // @@protoc_insertion_point(field_release:TxBlockStream.exchange_event)
  if (has_exchange_event()) {
    clear_has_txepoch();
      ::ExchangeEvent* temp = txepoch_.exchange_event_;
    txepoch_.exchange_event_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::ExchangeEvent& TxBlockStream::exchange_event() const {
  // @@protoc_insertion_point(field_get:TxBlockStream.exchange_event)
  return has_exchange_event()
      ? *txepoch_.exchange_event_
      : *reinterpret_cast< ::ExchangeEvent*>(&::_ExchangeEvent_default_instance_);
}
inline ::ExchangeEvent* TxBlockStream::mutable_exchange_event() {
  if (!has_exchange_event()) {
    clear_txepoch();
    set_has_exchange_event();
    txepoch_.exchange_event_ = CreateMaybeMessage< ::ExchangeEvent >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:TxBlockStream.exchange_event)
  return txepoch_.exchange_event_;
}

inline bool TxBlockStream::has_txepoch() const {
  return txepoch_case() != TXEPOCH_NOT_SET;
}
inline void TxBlockStream::clear_has_txepoch() {
  _oneof_case_[0] = TXEPOCH_NOT_SET;
}
inline TxBlockStream::TxepochCase TxBlockStream::txepoch_case() const {
  return TxBlockStream::TxepochCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MarketQuote

// int32 bidsize = 10;
inline void MarketQuote::clear_bidsize() {
  bidsize_ = 0;
}
inline ::google::protobuf::int32 MarketQuote::bidsize() const {
  // @@protoc_insertion_point(field_get:MarketQuote.bidsize)
  return bidsize_;
}
inline void MarketQuote::set_bidsize(::google::protobuf::int32 value) {
  
  bidsize_ = value;
  // @@protoc_insertion_point(field_set:MarketQuote.bidsize)
}

// int32 bid = 20;
inline void MarketQuote::clear_bid() {
  bid_ = 0;
}
inline ::google::protobuf::int32 MarketQuote::bid() const {
  // @@protoc_insertion_point(field_get:MarketQuote.bid)
  return bid_;
}
inline void MarketQuote::set_bid(::google::protobuf::int32 value) {
  
  bid_ = value;
  // @@protoc_insertion_point(field_set:MarketQuote.bid)
}

// int32 ask = 30;
inline void MarketQuote::clear_ask() {
  ask_ = 0;
}
inline ::google::protobuf::int32 MarketQuote::ask() const {
  // @@protoc_insertion_point(field_get:MarketQuote.ask)
  return ask_;
}
inline void MarketQuote::set_ask(::google::protobuf::int32 value) {
  
  ask_ = value;
  // @@protoc_insertion_point(field_set:MarketQuote.ask)
}

// int32 asksize = 40;
inline void MarketQuote::clear_asksize() {
  asksize_ = 0;
}
inline ::google::protobuf::int32 MarketQuote::asksize() const {
  // @@protoc_insertion_point(field_get:MarketQuote.asksize)
  return asksize_;
}
inline void MarketQuote::set_asksize(::google::protobuf::int32 value) {
  
  asksize_ = value;
  // @@protoc_insertion_point(field_set:MarketQuote.asksize)
}

// int32 last = 50;
inline void MarketQuote::clear_last() {
  last_ = 0;
}
inline ::google::protobuf::int32 MarketQuote::last() const {
  // @@protoc_insertion_point(field_get:MarketQuote.last)
  return last_;
}
inline void MarketQuote::set_last(::google::protobuf::int32 value) {
  
  last_ = value;
  // @@protoc_insertion_point(field_set:MarketQuote.last)
}

// int32 lastsize = 60;
inline void MarketQuote::clear_lastsize() {
  lastsize_ = 0;
}
inline ::google::protobuf::int32 MarketQuote::lastsize() const {
  // @@protoc_insertion_point(field_get:MarketQuote.lastsize)
  return lastsize_;
}
inline void MarketQuote::set_lastsize(::google::protobuf::int32 value) {
  
  lastsize_ = value;
  // @@protoc_insertion_point(field_set:MarketQuote.lastsize)
}

// bool upordown = 70;
inline void MarketQuote::clear_upordown() {
  upordown_ = false;
}
inline bool MarketQuote::upordown() const {
  // @@protoc_insertion_point(field_get:MarketQuote.upordown)
  return upordown_;
}
inline void MarketQuote::set_upordown(bool value) {
  
  upordown_ = value;
  // @@protoc_insertion_point(field_set:MarketQuote.upordown)
}

// string ticker = 80;
inline void MarketQuote::clear_ticker() {
  ticker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MarketQuote::ticker() const {
  // @@protoc_insertion_point(field_get:MarketQuote.ticker)
  return ticker_.GetNoArena();
}
inline void MarketQuote::set_ticker(const ::std::string& value) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:MarketQuote.ticker)
}
#if LANG_CXX11
inline void MarketQuote::set_ticker(::std::string&& value) {
  
  ticker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:MarketQuote.ticker)
}
#endif
inline void MarketQuote::set_ticker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:MarketQuote.ticker)
}
inline void MarketQuote::set_ticker(const char* value, size_t size) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:MarketQuote.ticker)
}
inline ::std::string* MarketQuote::mutable_ticker() {
  
  // @@protoc_insertion_point(field_mutable:MarketQuote.ticker)
  return ticker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MarketQuote::release_ticker() {
  // @@protoc_insertion_point(field_release:MarketQuote.ticker)
  
  return ticker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MarketQuote::set_allocated_ticker(::std::string* ticker) {
  if (ticker != NULL) {
    
  } else {
    
  }
  ticker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticker);
  // @@protoc_insertion_point(field_set_allocated:MarketQuote.ticker)
}

// uint64 epoch = 90;
inline void MarketQuote::clear_epoch() {
  epoch_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 MarketQuote::epoch() const {
  // @@protoc_insertion_point(field_get:MarketQuote.epoch)
  return epoch_;
}
inline void MarketQuote::set_epoch(::google::protobuf::uint64 value) {
  
  epoch_ = value;
  // @@protoc_insertion_point(field_set:MarketQuote.epoch)
}

// -------------------------------------------------------------------

// EpochBar

// string ticker = 10;
inline void EpochBar::clear_ticker() {
  ticker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& EpochBar::ticker() const {
  // @@protoc_insertion_point(field_get:EpochBar.ticker)
  return ticker_.GetNoArena();
}
inline void EpochBar::set_ticker(const ::std::string& value) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:EpochBar.ticker)
}
#if LANG_CXX11
inline void EpochBar::set_ticker(::std::string&& value) {
  
  ticker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:EpochBar.ticker)
}
#endif
inline void EpochBar::set_ticker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:EpochBar.ticker)
}
inline void EpochBar::set_ticker(const char* value, size_t size) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:EpochBar.ticker)
}
inline ::std::string* EpochBar::mutable_ticker() {
  
  // @@protoc_insertion_point(field_mutable:EpochBar.ticker)
  return ticker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* EpochBar::release_ticker() {
  // @@protoc_insertion_point(field_release:EpochBar.ticker)
  
  return ticker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void EpochBar::set_allocated_ticker(::std::string* ticker) {
  if (ticker != NULL) {
    
  } else {
    
  }
  ticker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticker);
  // @@protoc_insertion_point(field_set_allocated:EpochBar.ticker)
}

// uint64 epoch = 15;
inline void EpochBar::clear_epoch() {
  epoch_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 EpochBar::epoch() const {
  // @@protoc_insertion_point(field_get:EpochBar.epoch)
  return epoch_;
}
inline void EpochBar::set_epoch(::google::protobuf::uint64 value) {
  
  epoch_ = value;
  // @@protoc_insertion_point(field_set:EpochBar.epoch)
}

// int32 open = 20;
inline void EpochBar::clear_open() {
  open_ = 0;
}
inline ::google::protobuf::int32 EpochBar::open() const {
  // @@protoc_insertion_point(field_get:EpochBar.open)
  return open_;
}
inline void EpochBar::set_open(::google::protobuf::int32 value) {
  
  open_ = value;
  // @@protoc_insertion_point(field_set:EpochBar.open)
}

// int32 high = 30;
inline void EpochBar::clear_high() {
  high_ = 0;
}
inline ::google::protobuf::int32 EpochBar::high() const {
  // @@protoc_insertion_point(field_get:EpochBar.high)
  return high_;
}
inline void EpochBar::set_high(::google::protobuf::int32 value) {
  
  high_ = value;
  // @@protoc_insertion_point(field_set:EpochBar.high)
}

// int32 low = 40;
inline void EpochBar::clear_low() {
  low_ = 0;
}
inline ::google::protobuf::int32 EpochBar::low() const {
  // @@protoc_insertion_point(field_get:EpochBar.low)
  return low_;
}
inline void EpochBar::set_low(::google::protobuf::int32 value) {
  
  low_ = value;
  // @@protoc_insertion_point(field_set:EpochBar.low)
}

// int32 close = 50;
inline void EpochBar::clear_close() {
  close_ = 0;
}
inline ::google::protobuf::int32 EpochBar::close() const {
  // @@protoc_insertion_point(field_get:EpochBar.close)
  return close_;
}
inline void EpochBar::set_close(::google::protobuf::int32 value) {
  
  close_ = value;
  // @@protoc_insertion_point(field_set:EpochBar.close)
}

// int32 volume = 60;
inline void EpochBar::clear_volume() {
  volume_ = 0;
}
inline ::google::protobuf::int32 EpochBar::volume() const {
  // @@protoc_insertion_point(field_get:EpochBar.volume)
  return volume_;
}
inline void EpochBar::set_volume(::google::protobuf::int32 value) {
  
  volume_ = value;
  // @@protoc_insertion_point(field_set:EpochBar.volume)
}

// -------------------------------------------------------------------

// ContractBar

// string ticker = 10;
inline void ContractBar::clear_ticker() {
  ticker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ContractBar::ticker() const {
  // @@protoc_insertion_point(field_get:ContractBar.ticker)
  return ticker_.GetNoArena();
}
inline void ContractBar::set_ticker(const ::std::string& value) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ContractBar.ticker)
}
#if LANG_CXX11
inline void ContractBar::set_ticker(::std::string&& value) {
  
  ticker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ContractBar.ticker)
}
#endif
inline void ContractBar::set_ticker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ContractBar.ticker)
}
inline void ContractBar::set_ticker(const char* value, size_t size) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ContractBar.ticker)
}
inline ::std::string* ContractBar::mutable_ticker() {
  
  // @@protoc_insertion_point(field_mutable:ContractBar.ticker)
  return ticker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ContractBar::release_ticker() {
  // @@protoc_insertion_point(field_release:ContractBar.ticker)
  
  return ticker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ContractBar::set_allocated_ticker(::std::string* ticker) {
  if (ticker != NULL) {
    
  } else {
    
  }
  ticker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticker);
  // @@protoc_insertion_point(field_set_allocated:ContractBar.ticker)
}

// uint64 epoch = 15;
inline void ContractBar::clear_epoch() {
  epoch_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 ContractBar::epoch() const {
  // @@protoc_insertion_point(field_get:ContractBar.epoch)
  return epoch_;
}
inline void ContractBar::set_epoch(::google::protobuf::uint64 value) {
  
  epoch_ = value;
  // @@protoc_insertion_point(field_set:ContractBar.epoch)
}

// int32 day_open = 20;
inline void ContractBar::clear_day_open() {
  day_open_ = 0;
}
inline ::google::protobuf::int32 ContractBar::day_open() const {
  // @@protoc_insertion_point(field_get:ContractBar.day_open)
  return day_open_;
}
inline void ContractBar::set_day_open(::google::protobuf::int32 value) {
  
  day_open_ = value;
  // @@protoc_insertion_point(field_set:ContractBar.day_open)
}

// int32 day_high = 30;
inline void ContractBar::clear_day_high() {
  day_high_ = 0;
}
inline ::google::protobuf::int32 ContractBar::day_high() const {
  // @@protoc_insertion_point(field_get:ContractBar.day_high)
  return day_high_;
}
inline void ContractBar::set_day_high(::google::protobuf::int32 value) {
  
  day_high_ = value;
  // @@protoc_insertion_point(field_set:ContractBar.day_high)
}

// int32 day_low = 40;
inline void ContractBar::clear_day_low() {
  day_low_ = 0;
}
inline ::google::protobuf::int32 ContractBar::day_low() const {
  // @@protoc_insertion_point(field_get:ContractBar.day_low)
  return day_low_;
}
inline void ContractBar::set_day_low(::google::protobuf::int32 value) {
  
  day_low_ = value;
  // @@protoc_insertion_point(field_set:ContractBar.day_low)
}

// int32 day_close = 50;
inline void ContractBar::clear_day_close() {
  day_close_ = 0;
}
inline ::google::protobuf::int32 ContractBar::day_close() const {
  // @@protoc_insertion_point(field_get:ContractBar.day_close)
  return day_close_;
}
inline void ContractBar::set_day_close(::google::protobuf::int32 value) {
  
  day_close_ = value;
  // @@protoc_insertion_point(field_set:ContractBar.day_close)
}

// int32 day_volume = 60;
inline void ContractBar::clear_day_volume() {
  day_volume_ = 0;
}
inline ::google::protobuf::int32 ContractBar::day_volume() const {
  // @@protoc_insertion_point(field_get:ContractBar.day_volume)
  return day_volume_;
}
inline void ContractBar::set_day_volume(::google::protobuf::int32 value) {
  
  day_volume_ = value;
  // @@protoc_insertion_point(field_set:ContractBar.day_volume)
}

// int32 high = 70;
inline void ContractBar::clear_high() {
  high_ = 0;
}
inline ::google::protobuf::int32 ContractBar::high() const {
  // @@protoc_insertion_point(field_get:ContractBar.high)
  return high_;
}
inline void ContractBar::set_high(::google::protobuf::int32 value) {
  
  high_ = value;
  // @@protoc_insertion_point(field_set:ContractBar.high)
}

// int32 low = 80;
inline void ContractBar::clear_low() {
  low_ = 0;
}
inline ::google::protobuf::int32 ContractBar::low() const {
  // @@protoc_insertion_point(field_get:ContractBar.low)
  return low_;
}
inline void ContractBar::set_low(::google::protobuf::int32 value) {
  
  low_ = value;
  // @@protoc_insertion_point(field_set:ContractBar.low)
}

// int32 volume = 90;
inline void ContractBar::clear_volume() {
  volume_ = 0;
}
inline ::google::protobuf::int32 ContractBar::volume() const {
  // @@protoc_insertion_point(field_get:ContractBar.volume)
  return volume_;
}
inline void ContractBar::set_volume(::google::protobuf::int32 value) {
  
  volume_ = value;
  // @@protoc_insertion_point(field_set:ContractBar.volume)
}

// int32 open_interest = 100;
inline void ContractBar::clear_open_interest() {
  open_interest_ = 0;
}
inline ::google::protobuf::int32 ContractBar::open_interest() const {
  // @@protoc_insertion_point(field_get:ContractBar.open_interest)
  return open_interest_;
}
inline void ContractBar::set_open_interest(::google::protobuf::int32 value) {
  
  open_interest_ = value;
  // @@protoc_insertion_point(field_set:ContractBar.open_interest)
}

// int32 previous_close = 110;
inline void ContractBar::clear_previous_close() {
  previous_close_ = 0;
}
inline ::google::protobuf::int32 ContractBar::previous_close() const {
  // @@protoc_insertion_point(field_get:ContractBar.previous_close)
  return previous_close_;
}
inline void ContractBar::set_previous_close(::google::protobuf::int32 value) {
  
  previous_close_ = value;
  // @@protoc_insertion_point(field_set:ContractBar.previous_close)
}

// -------------------------------------------------------------------

// BookOrder

// sint32 side = 10;
inline void BookOrder::clear_side() {
  side_ = 0;
}
inline ::google::protobuf::int32 BookOrder::side() const {
  // @@protoc_insertion_point(field_get:BookOrder.side)
  return side_;
}
inline void BookOrder::set_side(::google::protobuf::int32 value) {
  
  side_ = value;
  // @@protoc_insertion_point(field_set:BookOrder.side)
}

// int32 price = 20;
inline void BookOrder::clear_price() {
  price_ = 0;
}
inline ::google::protobuf::int32 BookOrder::price() const {
  // @@protoc_insertion_point(field_get:BookOrder.price)
  return price_;
}
inline void BookOrder::set_price(::google::protobuf::int32 value) {
  
  price_ = value;
  // @@protoc_insertion_point(field_set:BookOrder.price)
}

// int32 open_qty = 30;
inline void BookOrder::clear_open_qty() {
  open_qty_ = 0;
}
inline ::google::protobuf::int32 BookOrder::open_qty() const {
  // @@protoc_insertion_point(field_get:BookOrder.open_qty)
  return open_qty_;
}
inline void BookOrder::set_open_qty(::google::protobuf::int32 value) {
  
  open_qty_ = value;
  // @@protoc_insertion_point(field_set:BookOrder.open_qty)
}

// int32 filled_qty = 40;
inline void BookOrder::clear_filled_qty() {
  filled_qty_ = 0;
}
inline ::google::protobuf::int32 BookOrder::filled_qty() const {
  // @@protoc_insertion_point(field_get:BookOrder.filled_qty)
  return filled_qty_;
}
inline void BookOrder::set_filled_qty(::google::protobuf::int32 value) {
  
  filled_qty_ = value;
  // @@protoc_insertion_point(field_set:BookOrder.filled_qty)
}

// int32 remaining_qty = 50;
inline void BookOrder::clear_remaining_qty() {
  remaining_qty_ = 0;
}
inline ::google::protobuf::int32 BookOrder::remaining_qty() const {
  // @@protoc_insertion_point(field_get:BookOrder.remaining_qty)
  return remaining_qty_;
}
inline void BookOrder::set_remaining_qty(::google::protobuf::int32 value) {
  
  remaining_qty_ = value;
  // @@protoc_insertion_point(field_set:BookOrder.remaining_qty)
}

// int32 canceled_qty = 60;
inline void BookOrder::clear_canceled_qty() {
  canceled_qty_ = 0;
}
inline ::google::protobuf::int32 BookOrder::canceled_qty() const {
  // @@protoc_insertion_point(field_get:BookOrder.canceled_qty)
  return canceled_qty_;
}
inline void BookOrder::set_canceled_qty(::google::protobuf::int32 value) {
  
  canceled_qty_ = value;
  // @@protoc_insertion_point(field_set:BookOrder.canceled_qty)
}

// int32 agres_fill_qty = 62;
inline void BookOrder::clear_agres_fill_qty() {
  agres_fill_qty_ = 0;
}
inline ::google::protobuf::int32 BookOrder::agres_fill_qty() const {
  // @@protoc_insertion_point(field_get:BookOrder.agres_fill_qty)
  return agres_fill_qty_;
}
inline void BookOrder::set_agres_fill_qty(::google::protobuf::int32 value) {
  
  agres_fill_qty_ = value;
  // @@protoc_insertion_point(field_set:BookOrder.agres_fill_qty)
}

// float agres_avg_price = 63;
inline void BookOrder::clear_agres_avg_price() {
  agres_avg_price_ = 0;
}
inline float BookOrder::agres_avg_price() const {
  // @@protoc_insertion_point(field_get:BookOrder.agres_avg_price)
  return agres_avg_price_;
}
inline void BookOrder::set_agres_avg_price(float value) {
  
  agres_avg_price_ = value;
  // @@protoc_insertion_point(field_set:BookOrder.agres_avg_price)
}

// int32 pass_fill_qty = 64;
inline void BookOrder::clear_pass_fill_qty() {
  pass_fill_qty_ = 0;
}
inline ::google::protobuf::int32 BookOrder::pass_fill_qty() const {
  // @@protoc_insertion_point(field_get:BookOrder.pass_fill_qty)
  return pass_fill_qty_;
}
inline void BookOrder::set_pass_fill_qty(::google::protobuf::int32 value) {
  
  pass_fill_qty_ = value;
  // @@protoc_insertion_point(field_set:BookOrder.pass_fill_qty)
}

// float avg_price = 65;
inline void BookOrder::clear_avg_price() {
  avg_price_ = 0;
}
inline float BookOrder::avg_price() const {
  // @@protoc_insertion_point(field_get:BookOrder.avg_price)
  return avg_price_;
}
inline void BookOrder::set_avg_price(float value) {
  
  avg_price_ = value;
  // @@protoc_insertion_point(field_set:BookOrder.avg_price)
}

// string ticker = 70;
inline void BookOrder::clear_ticker() {
  ticker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BookOrder::ticker() const {
  // @@protoc_insertion_point(field_get:BookOrder.ticker)
  return ticker_.GetNoArena();
}
inline void BookOrder::set_ticker(const ::std::string& value) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BookOrder.ticker)
}
#if LANG_CXX11
inline void BookOrder::set_ticker(::std::string&& value) {
  
  ticker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BookOrder.ticker)
}
#endif
inline void BookOrder::set_ticker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BookOrder.ticker)
}
inline void BookOrder::set_ticker(const char* value, size_t size) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BookOrder.ticker)
}
inline ::std::string* BookOrder::mutable_ticker() {
  
  // @@protoc_insertion_point(field_mutable:BookOrder.ticker)
  return ticker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BookOrder::release_ticker() {
  // @@protoc_insertion_point(field_release:BookOrder.ticker)
  
  return ticker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BookOrder::set_allocated_ticker(::std::string* ticker) {
  if (ticker != NULL) {
    
  } else {
    
  }
  ticker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticker);
  // @@protoc_insertion_point(field_set_allocated:BookOrder.ticker)
}

// string update_time = 80;
inline void BookOrder::clear_update_time() {
  update_time_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BookOrder::update_time() const {
  // @@protoc_insertion_point(field_get:BookOrder.update_time)
  return update_time_.GetNoArena();
}
inline void BookOrder::set_update_time(const ::std::string& value) {
  
  update_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BookOrder.update_time)
}
#if LANG_CXX11
inline void BookOrder::set_update_time(::std::string&& value) {
  
  update_time_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BookOrder.update_time)
}
#endif
inline void BookOrder::set_update_time(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  update_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BookOrder.update_time)
}
inline void BookOrder::set_update_time(const char* value, size_t size) {
  
  update_time_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BookOrder.update_time)
}
inline ::std::string* BookOrder::mutable_update_time() {
  
  // @@protoc_insertion_point(field_mutable:BookOrder.update_time)
  return update_time_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BookOrder::release_update_time() {
  // @@protoc_insertion_point(field_release:BookOrder.update_time)
  
  return update_time_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BookOrder::set_allocated_update_time(::std::string* update_time) {
  if (update_time != NULL) {
    
  } else {
    
  }
  update_time_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), update_time);
  // @@protoc_insertion_point(field_set_allocated:BookOrder.update_time)
}

// string orderid = 90;
inline void BookOrder::clear_orderid() {
  orderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BookOrder::orderid() const {
  // @@protoc_insertion_point(field_get:BookOrder.orderid)
  return orderid_.GetNoArena();
}
inline void BookOrder::set_orderid(const ::std::string& value) {
  
  orderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BookOrder.orderid)
}
#if LANG_CXX11
inline void BookOrder::set_orderid(::std::string&& value) {
  
  orderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BookOrder.orderid)
}
#endif
inline void BookOrder::set_orderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  orderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BookOrder.orderid)
}
inline void BookOrder::set_orderid(const char* value, size_t size) {
  
  orderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BookOrder.orderid)
}
inline ::std::string* BookOrder::mutable_orderid() {
  
  // @@protoc_insertion_point(field_mutable:BookOrder.orderid)
  return orderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BookOrder::release_orderid() {
  // @@protoc_insertion_point(field_release:BookOrder.orderid)
  
  return orderid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BookOrder::set_allocated_orderid(::std::string* orderid) {
  if (orderid != NULL) {
    
  } else {
    
  }
  orderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), orderid);
  // @@protoc_insertion_point(field_set_allocated:BookOrder.orderid)
}

// string traderid = 100;
inline void BookOrder::clear_traderid() {
  traderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BookOrder::traderid() const {
  // @@protoc_insertion_point(field_get:BookOrder.traderid)
  return traderid_.GetNoArena();
}
inline void BookOrder::set_traderid(const ::std::string& value) {
  
  traderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BookOrder.traderid)
}
#if LANG_CXX11
inline void BookOrder::set_traderid(::std::string&& value) {
  
  traderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BookOrder.traderid)
}
#endif
inline void BookOrder::set_traderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  traderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BookOrder.traderid)
}
inline void BookOrder::set_traderid(const char* value, size_t size) {
  
  traderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BookOrder.traderid)
}
inline ::std::string* BookOrder::mutable_traderid() {
  
  // @@protoc_insertion_point(field_mutable:BookOrder.traderid)
  return traderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BookOrder::release_traderid() {
  // @@protoc_insertion_point(field_release:BookOrder.traderid)
  
  return traderid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BookOrder::set_allocated_traderid(::std::string* traderid) {
  if (traderid != NULL) {
    
  } else {
    
  }
  traderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), traderid);
  // @@protoc_insertion_point(field_set_allocated:BookOrder.traderid)
}

// -------------------------------------------------------------------

// DepthItem

// int32 level = 10;
inline void DepthItem::clear_level() {
  level_ = 0;
}
inline ::google::protobuf::int32 DepthItem::level() const {
  // @@protoc_insertion_point(field_get:DepthItem.level)
  return level_;
}
inline void DepthItem::set_level(::google::protobuf::int32 value) {
  
  level_ = value;
  // @@protoc_insertion_point(field_set:DepthItem.level)
}

// int32 b = 30;
inline void DepthItem::clear_b() {
  b_ = 0;
}
inline ::google::protobuf::int32 DepthItem::b() const {
  // @@protoc_insertion_point(field_get:DepthItem.b)
  return b_;
}
inline void DepthItem::set_b(::google::protobuf::int32 value) {
  
  b_ = value;
  // @@protoc_insertion_point(field_set:DepthItem.b)
}

// int32 a = 40;
inline void DepthItem::clear_a() {
  a_ = 0;
}
inline ::google::protobuf::int32 DepthItem::a() const {
  // @@protoc_insertion_point(field_get:DepthItem.a)
  return a_;
}
inline void DepthItem::set_a(::google::protobuf::int32 value) {
  
  a_ = value;
  // @@protoc_insertion_point(field_set:DepthItem.a)
}

// int32 bs = 50;
inline void DepthItem::clear_bs() {
  bs_ = 0;
}
inline ::google::protobuf::int32 DepthItem::bs() const {
  // @@protoc_insertion_point(field_get:DepthItem.bs)
  return bs_;
}
inline void DepthItem::set_bs(::google::protobuf::int32 value) {
  
  bs_ = value;
  // @@protoc_insertion_point(field_set:DepthItem.bs)
}

// int32 as = 60;
inline void DepthItem::clear_as() {
  as_ = 0;
}
inline ::google::protobuf::int32 DepthItem::as() const {
  // @@protoc_insertion_point(field_get:DepthItem.as)
  return as_;
}
inline void DepthItem::set_as(::google::protobuf::int32 value) {
  
  as_ = value;
  // @@protoc_insertion_point(field_set:DepthItem.as)
}

// -------------------------------------------------------------------

// MarketData

// int32 version = 1;
inline void MarketData::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 MarketData::version() const {
  // @@protoc_insertion_point(field_get:MarketData.version)
  return version_;
}
inline void MarketData::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:MarketData.version)
}

// uint64 epoch = 10;
inline void MarketData::clear_epoch() {
  epoch_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 MarketData::epoch() const {
  // @@protoc_insertion_point(field_get:MarketData.epoch)
  return epoch_;
}
inline void MarketData::set_epoch(::google::protobuf::uint64 value) {
  
  epoch_ = value;
  // @@protoc_insertion_point(field_set:MarketData.epoch)
}

// .EpochBar bar = 20;
inline bool MarketData::has_bar() const {
  return this != internal_default_instance() && bar_ != NULL;
}
inline void MarketData::clear_bar() {
  if (GetArenaNoVirtual() == NULL && bar_ != NULL) {
    delete bar_;
  }
  bar_ = NULL;
}
inline const ::EpochBar& MarketData::_internal_bar() const {
  return *bar_;
}
inline const ::EpochBar& MarketData::bar() const {
  const ::EpochBar* p = bar_;
  // @@protoc_insertion_point(field_get:MarketData.bar)
  return p != NULL ? *p : *reinterpret_cast<const ::EpochBar*>(
      &::_EpochBar_default_instance_);
}
inline ::EpochBar* MarketData::release_bar() {
  // @@protoc_insertion_point(field_release:MarketData.bar)
  
  ::EpochBar* temp = bar_;
  bar_ = NULL;
  return temp;
}
inline ::EpochBar* MarketData::mutable_bar() {
  
  if (bar_ == NULL) {
    auto* p = CreateMaybeMessage<::EpochBar>(GetArenaNoVirtual());
    bar_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MarketData.bar)
  return bar_;
}
inline void MarketData::set_allocated_bar(::EpochBar* bar) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bar_;
  }
  if (bar) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bar = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bar, submessage_arena);
    }
    
  } else {
    
  }
  bar_ = bar;
  // @@protoc_insertion_point(field_set_allocated:MarketData.bar)
}

// .MarketQuote quote = 30;
inline bool MarketData::has_quote() const {
  return this != internal_default_instance() && quote_ != NULL;
}
inline void MarketData::clear_quote() {
  if (GetArenaNoVirtual() == NULL && quote_ != NULL) {
    delete quote_;
  }
  quote_ = NULL;
}
inline const ::MarketQuote& MarketData::_internal_quote() const {
  return *quote_;
}
inline const ::MarketQuote& MarketData::quote() const {
  const ::MarketQuote* p = quote_;
  // @@protoc_insertion_point(field_get:MarketData.quote)
  return p != NULL ? *p : *reinterpret_cast<const ::MarketQuote*>(
      &::_MarketQuote_default_instance_);
}
inline ::MarketQuote* MarketData::release_quote() {
  // @@protoc_insertion_point(field_release:MarketData.quote)
  
  ::MarketQuote* temp = quote_;
  quote_ = NULL;
  return temp;
}
inline ::MarketQuote* MarketData::mutable_quote() {
  
  if (quote_ == NULL) {
    auto* p = CreateMaybeMessage<::MarketQuote>(GetArenaNoVirtual());
    quote_ = p;
  }
  // @@protoc_insertion_point(field_mutable:MarketData.quote)
  return quote_;
}
inline void MarketData::set_allocated_quote(::MarketQuote* quote) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete quote_;
  }
  if (quote) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      quote = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quote, submessage_arena);
    }
    
  } else {
    
  }
  quote_ = quote;
  // @@protoc_insertion_point(field_set_allocated:MarketData.quote)
}

// repeated .DepthItem depth = 40;
inline int MarketData::depth_size() const {
  return depth_.size();
}
inline void MarketData::clear_depth() {
  depth_.Clear();
}
inline ::DepthItem* MarketData::mutable_depth(int index) {
  // @@protoc_insertion_point(field_mutable:MarketData.depth)
  return depth_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::DepthItem >*
MarketData::mutable_depth() {
  // @@protoc_insertion_point(field_mutable_list:MarketData.depth)
  return &depth_;
}
inline const ::DepthItem& MarketData::depth(int index) const {
  // @@protoc_insertion_point(field_get:MarketData.depth)
  return depth_.Get(index);
}
inline ::DepthItem* MarketData::add_depth() {
  // @@protoc_insertion_point(field_add:MarketData.depth)
  return depth_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::DepthItem >&
MarketData::depth() const {
  // @@protoc_insertion_point(field_list:MarketData.depth)
  return depth_;
}

// -------------------------------------------------------------------

// FillData

// string agressiveid = 10;
inline void FillData::clear_agressiveid() {
  agressiveid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FillData::agressiveid() const {
  // @@protoc_insertion_point(field_get:FillData.agressiveid)
  return agressiveid_.GetNoArena();
}
inline void FillData::set_agressiveid(const ::std::string& value) {
  
  agressiveid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FillData.agressiveid)
}
#if LANG_CXX11
inline void FillData::set_agressiveid(::std::string&& value) {
  
  agressiveid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FillData.agressiveid)
}
#endif
inline void FillData::set_agressiveid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  agressiveid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FillData.agressiveid)
}
inline void FillData::set_agressiveid(const char* value, size_t size) {
  
  agressiveid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FillData.agressiveid)
}
inline ::std::string* FillData::mutable_agressiveid() {
  
  // @@protoc_insertion_point(field_mutable:FillData.agressiveid)
  return agressiveid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FillData::release_agressiveid() {
  // @@protoc_insertion_point(field_release:FillData.agressiveid)
  
  return agressiveid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FillData::set_allocated_agressiveid(::std::string* agressiveid) {
  if (agressiveid != NULL) {
    
  } else {
    
  }
  agressiveid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), agressiveid);
  // @@protoc_insertion_point(field_set_allocated:FillData.agressiveid)
}

// string passiveid = 20;
inline void FillData::clear_passiveid() {
  passiveid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FillData::passiveid() const {
  // @@protoc_insertion_point(field_get:FillData.passiveid)
  return passiveid_.GetNoArena();
}
inline void FillData::set_passiveid(const ::std::string& value) {
  
  passiveid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:FillData.passiveid)
}
#if LANG_CXX11
inline void FillData::set_passiveid(::std::string&& value) {
  
  passiveid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:FillData.passiveid)
}
#endif
inline void FillData::set_passiveid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  passiveid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:FillData.passiveid)
}
inline void FillData::set_passiveid(const char* value, size_t size) {
  
  passiveid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:FillData.passiveid)
}
inline ::std::string* FillData::mutable_passiveid() {
  
  // @@protoc_insertion_point(field_mutable:FillData.passiveid)
  return passiveid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FillData::release_passiveid() {
  // @@protoc_insertion_point(field_release:FillData.passiveid)
  
  return passiveid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FillData::set_allocated_passiveid(::std::string* passiveid) {
  if (passiveid != NULL) {
    
  } else {
    
  }
  passiveid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), passiveid);
  // @@protoc_insertion_point(field_set_allocated:FillData.passiveid)
}

// uint32 price = 30;
inline void FillData::clear_price() {
  price_ = 0u;
}
inline ::google::protobuf::uint32 FillData::price() const {
  // @@protoc_insertion_point(field_get:FillData.price)
  return price_;
}
inline void FillData::set_price(::google::protobuf::uint32 value) {
  
  price_ = value;
  // @@protoc_insertion_point(field_set:FillData.price)
}

// uint32 qty = 40;
inline void FillData::clear_qty() {
  qty_ = 0u;
}
inline ::google::protobuf::uint32 FillData::qty() const {
  // @@protoc_insertion_point(field_get:FillData.qty)
  return qty_;
}
inline void FillData::set_qty(::google::protobuf::uint32 value) {
  
  qty_ = value;
  // @@protoc_insertion_point(field_set:FillData.qty)
}

// int32 agressive_side = 50;
inline void FillData::clear_agressive_side() {
  agressive_side_ = 0;
}
inline ::google::protobuf::int32 FillData::agressive_side() const {
  // @@protoc_insertion_point(field_get:FillData.agressive_side)
  return agressive_side_;
}
inline void FillData::set_agressive_side(::google::protobuf::int32 value) {
  
  agressive_side_ = value;
  // @@protoc_insertion_point(field_set:FillData.agressive_side)
}

// uint64 microtime = 60;
inline void FillData::clear_microtime() {
  microtime_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FillData::microtime() const {
  // @@protoc_insertion_point(field_get:FillData.microtime)
  return microtime_;
}
inline void FillData::set_microtime(::google::protobuf::uint64 value) {
  
  microtime_ = value;
  // @@protoc_insertion_point(field_set:FillData.microtime)
}

// -------------------------------------------------------------------

// OrderData

// int32 version = 1;
inline void OrderData::clear_version() {
  version_ = 0;
}
inline ::google::protobuf::int32 OrderData::version() const {
  // @@protoc_insertion_point(field_get:OrderData.version)
  return version_;
}
inline void OrderData::set_version(::google::protobuf::int32 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:OrderData.version)
}

// uint64 epoch = 10;
inline void OrderData::clear_epoch() {
  epoch_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 OrderData::epoch() const {
  // @@protoc_insertion_point(field_get:OrderData.epoch)
  return epoch_;
}
inline void OrderData::set_epoch(::google::protobuf::uint64 value) {
  
  epoch_ = value;
  // @@protoc_insertion_point(field_set:OrderData.epoch)
}

// repeated .BookOrder bookorders = 40;
inline int OrderData::bookorders_size() const {
  return bookorders_.size();
}
inline void OrderData::clear_bookorders() {
  bookorders_.Clear();
}
inline ::BookOrder* OrderData::mutable_bookorders(int index) {
  // @@protoc_insertion_point(field_mutable:OrderData.bookorders)
  return bookorders_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::BookOrder >*
OrderData::mutable_bookorders() {
  // @@protoc_insertion_point(field_mutable_list:OrderData.bookorders)
  return &bookorders_;
}
inline const ::BookOrder& OrderData::bookorders(int index) const {
  // @@protoc_insertion_point(field_get:OrderData.bookorders)
  return bookorders_.Get(index);
}
inline ::BookOrder* OrderData::add_bookorders() {
  // @@protoc_insertion_point(field_add:OrderData.bookorders)
  return bookorders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BookOrder >&
OrderData::bookorders() const {
  // @@protoc_insertion_point(field_list:OrderData.bookorders)
  return bookorders_;
}

// repeated .FillData fills = 50;
inline int OrderData::fills_size() const {
  return fills_.size();
}
inline void OrderData::clear_fills() {
  fills_.Clear();
}
inline ::FillData* OrderData::mutable_fills(int index) {
  // @@protoc_insertion_point(field_mutable:OrderData.fills)
  return fills_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::FillData >*
OrderData::mutable_fills() {
  // @@protoc_insertion_point(field_mutable_list:OrderData.fills)
  return &fills_;
}
inline const ::FillData& OrderData::fills(int index) const {
  // @@protoc_insertion_point(field_get:OrderData.fills)
  return fills_.Get(index);
}
inline ::FillData* OrderData::add_fills() {
  // @@protoc_insertion_point(field_add:OrderData.fills)
  return fills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FillData >&
OrderData::fills() const {
  // @@protoc_insertion_point(field_list:OrderData.fills)
  return fills_;
}

// -------------------------------------------------------------------

// Contract

// string symbol = 10;
inline void Contract::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Contract::symbol() const {
  // @@protoc_insertion_point(field_get:Contract.symbol)
  return symbol_.GetNoArena();
}
inline void Contract::set_symbol(const ::std::string& value) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Contract.symbol)
}
#if LANG_CXX11
inline void Contract::set_symbol(::std::string&& value) {
  
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Contract.symbol)
}
#endif
inline void Contract::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Contract.symbol)
}
inline void Contract::set_symbol(const char* value, size_t size) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Contract.symbol)
}
inline ::std::string* Contract::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:Contract.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Contract::release_symbol() {
  // @@protoc_insertion_point(field_release:Contract.symbol)
  
  return symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Contract::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:Contract.symbol)
}

// uint32 unit_size = 20;
inline void Contract::clear_unit_size() {
  unit_size_ = 0u;
}
inline ::google::protobuf::uint32 Contract::unit_size() const {
  // @@protoc_insertion_point(field_get:Contract.unit_size)
  return unit_size_;
}
inline void Contract::set_unit_size(::google::protobuf::uint32 value) {
  
  unit_size_ = value;
  // @@protoc_insertion_point(field_set:Contract.unit_size)
}

// string unit = 30;
inline void Contract::clear_unit() {
  unit_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Contract::unit() const {
  // @@protoc_insertion_point(field_get:Contract.unit)
  return unit_.GetNoArena();
}
inline void Contract::set_unit(const ::std::string& value) {
  
  unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Contract.unit)
}
#if LANG_CXX11
inline void Contract::set_unit(::std::string&& value) {
  
  unit_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Contract.unit)
}
#endif
inline void Contract::set_unit(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Contract.unit)
}
inline void Contract::set_unit(const char* value, size_t size) {
  
  unit_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Contract.unit)
}
inline ::std::string* Contract::mutable_unit() {
  
  // @@protoc_insertion_point(field_mutable:Contract.unit)
  return unit_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Contract::release_unit() {
  // @@protoc_insertion_point(field_release:Contract.unit)
  
  return unit_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Contract::set_allocated_unit(::std::string* unit) {
  if (unit != NULL) {
    
  } else {
    
  }
  unit_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), unit);
  // @@protoc_insertion_point(field_set_allocated:Contract.unit)
}

// string price_quote = 40;
inline void Contract::clear_price_quote() {
  price_quote_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Contract::price_quote() const {
  // @@protoc_insertion_point(field_get:Contract.price_quote)
  return price_quote_.GetNoArena();
}
inline void Contract::set_price_quote(const ::std::string& value) {
  
  price_quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Contract.price_quote)
}
#if LANG_CXX11
inline void Contract::set_price_quote(::std::string&& value) {
  
  price_quote_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Contract.price_quote)
}
#endif
inline void Contract::set_price_quote(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  price_quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Contract.price_quote)
}
inline void Contract::set_price_quote(const char* value, size_t size) {
  
  price_quote_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Contract.price_quote)
}
inline ::std::string* Contract::mutable_price_quote() {
  
  // @@protoc_insertion_point(field_mutable:Contract.price_quote)
  return price_quote_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Contract::release_price_quote() {
  // @@protoc_insertion_point(field_release:Contract.price_quote)
  
  return price_quote_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Contract::set_allocated_price_quote(::std::string* price_quote) {
  if (price_quote != NULL) {
    
  } else {
    
  }
  price_quote_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), price_quote);
  // @@protoc_insertion_point(field_set_allocated:Contract.price_quote)
}

// int32 price_quote_units = 50;
inline void Contract::clear_price_quote_units() {
  price_quote_units_ = 0;
}
inline ::google::protobuf::int32 Contract::price_quote_units() const {
  // @@protoc_insertion_point(field_get:Contract.price_quote_units)
  return price_quote_units_;
}
inline void Contract::set_price_quote_units(::google::protobuf::int32 value) {
  
  price_quote_units_ = value;
  // @@protoc_insertion_point(field_set:Contract.price_quote_units)
}

// uint32 tic_min = 60;
inline void Contract::clear_tic_min() {
  tic_min_ = 0u;
}
inline ::google::protobuf::uint32 Contract::tic_min() const {
  // @@protoc_insertion_point(field_get:Contract.tic_min)
  return tic_min_;
}
inline void Contract::set_tic_min(::google::protobuf::uint32 value) {
  
  tic_min_ = value;
  // @@protoc_insertion_point(field_set:Contract.tic_min)
}

// uint32 tic_value = 70;
inline void Contract::clear_tic_value() {
  tic_value_ = 0u;
}
inline ::google::protobuf::uint32 Contract::tic_value() const {
  // @@protoc_insertion_point(field_get:Contract.tic_value)
  return tic_value_;
}
inline void Contract::set_tic_value(::google::protobuf::uint32 value) {
  
  tic_value_ = value;
  // @@protoc_insertion_point(field_set:Contract.tic_value)
}

// int32 price_limit_percent = 80;
inline void Contract::clear_price_limit_percent() {
  price_limit_percent_ = 0;
}
inline ::google::protobuf::int32 Contract::price_limit_percent() const {
  // @@protoc_insertion_point(field_get:Contract.price_limit_percent)
  return price_limit_percent_;
}
inline void Contract::set_price_limit_percent(::google::protobuf::int32 value) {
  
  price_limit_percent_ = value;
  // @@protoc_insertion_point(field_set:Contract.price_limit_percent)
}

// uint64 initial_margin = 90;
inline void Contract::clear_initial_margin() {
  initial_margin_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Contract::initial_margin() const {
  // @@protoc_insertion_point(field_get:Contract.initial_margin)
  return initial_margin_;
}
inline void Contract::set_initial_margin(::google::protobuf::uint64 value) {
  
  initial_margin_ = value;
  // @@protoc_insertion_point(field_set:Contract.initial_margin)
}

// uint64 maint_margin = 100;
inline void Contract::clear_maint_margin() {
  maint_margin_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Contract::maint_margin() const {
  // @@protoc_insertion_point(field_get:Contract.maint_margin)
  return maint_margin_;
}
inline void Contract::set_maint_margin(::google::protobuf::uint64 value) {
  
  maint_margin_ = value;
  // @@protoc_insertion_point(field_set:Contract.maint_margin)
}

// int32 position_limits = 110;
inline void Contract::clear_position_limits() {
  position_limits_ = 0;
}
inline ::google::protobuf::int32 Contract::position_limits() const {
  // @@protoc_insertion_point(field_get:Contract.position_limits)
  return position_limits_;
}
inline void Contract::set_position_limits(::google::protobuf::int32 value) {
  
  position_limits_ = value;
  // @@protoc_insertion_point(field_set:Contract.position_limits)
}

// uint64 trading_open_time = 120;
inline void Contract::clear_trading_open_time() {
  trading_open_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Contract::trading_open_time() const {
  // @@protoc_insertion_point(field_get:Contract.trading_open_time)
  return trading_open_time_;
}
inline void Contract::set_trading_open_time(::google::protobuf::uint64 value) {
  
  trading_open_time_ = value;
  // @@protoc_insertion_point(field_set:Contract.trading_open_time)
}

// uint64 trading_close_time = 130;
inline void Contract::clear_trading_close_time() {
  trading_close_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Contract::trading_close_time() const {
  // @@protoc_insertion_point(field_get:Contract.trading_close_time)
  return trading_close_time_;
}
inline void Contract::set_trading_close_time(::google::protobuf::uint64 value) {
  
  trading_close_time_ = value;
  // @@protoc_insertion_point(field_set:Contract.trading_close_time)
}

// -------------------------------------------------------------------

// Product

// string ticker = 10;
inline void Product::clear_ticker() {
  ticker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Product::ticker() const {
  // @@protoc_insertion_point(field_get:Product.ticker)
  return ticker_.GetNoArena();
}
inline void Product::set_ticker(const ::std::string& value) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Product.ticker)
}
#if LANG_CXX11
inline void Product::set_ticker(::std::string&& value) {
  
  ticker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Product.ticker)
}
#endif
inline void Product::set_ticker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Product.ticker)
}
inline void Product::set_ticker(const char* value, size_t size) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Product.ticker)
}
inline ::std::string* Product::mutable_ticker() {
  
  // @@protoc_insertion_point(field_mutable:Product.ticker)
  return ticker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Product::release_ticker() {
  // @@protoc_insertion_point(field_release:Product.ticker)
  
  return ticker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Product::set_allocated_ticker(::std::string* ticker) {
  if (ticker != NULL) {
    
  } else {
    
  }
  ticker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticker);
  // @@protoc_insertion_point(field_set_allocated:Product.ticker)
}

// string contract_symbol = 20;
inline void Product::clear_contract_symbol() {
  contract_symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Product::contract_symbol() const {
  // @@protoc_insertion_point(field_get:Product.contract_symbol)
  return contract_symbol_.GetNoArena();
}
inline void Product::set_contract_symbol(const ::std::string& value) {
  
  contract_symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Product.contract_symbol)
}
#if LANG_CXX11
inline void Product::set_contract_symbol(::std::string&& value) {
  
  contract_symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Product.contract_symbol)
}
#endif
inline void Product::set_contract_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  contract_symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Product.contract_symbol)
}
inline void Product::set_contract_symbol(const char* value, size_t size) {
  
  contract_symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Product.contract_symbol)
}
inline ::std::string* Product::mutable_contract_symbol() {
  
  // @@protoc_insertion_point(field_mutable:Product.contract_symbol)
  return contract_symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Product::release_contract_symbol() {
  // @@protoc_insertion_point(field_release:Product.contract_symbol)
  
  return contract_symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Product::set_allocated_contract_symbol(::std::string* contract_symbol) {
  if (contract_symbol != NULL) {
    
  } else {
    
  }
  contract_symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contract_symbol);
  // @@protoc_insertion_point(field_set_allocated:Product.contract_symbol)
}

// uint64 expiration_date = 30;
inline void Product::clear_expiration_date() {
  expiration_date_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Product::expiration_date() const {
  // @@protoc_insertion_point(field_get:Product.expiration_date)
  return expiration_date_;
}
inline void Product::set_expiration_date(::google::protobuf::uint64 value) {
  
  expiration_date_ = value;
  // @@protoc_insertion_point(field_set:Product.expiration_date)
}

// uint64 start_trading_date = 40;
inline void Product::clear_start_trading_date() {
  start_trading_date_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Product::start_trading_date() const {
  // @@protoc_insertion_point(field_get:Product.start_trading_date)
  return start_trading_date_;
}
inline void Product::set_start_trading_date(::google::protobuf::uint64 value) {
  
  start_trading_date_ = value;
  // @@protoc_insertion_point(field_set:Product.start_trading_date)
}

// bool is_active = 50;
inline void Product::clear_is_active() {
  is_active_ = false;
}
inline bool Product::is_active() const {
  // @@protoc_insertion_point(field_get:Product.is_active)
  return is_active_;
}
inline void Product::set_is_active(bool value) {
  
  is_active_ = value;
  // @@protoc_insertion_point(field_set:Product.is_active)
}

// -------------------------------------------------------------------

// Schedule

// uint64 date = 10;
inline void Schedule::clear_date() {
  date_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Schedule::date() const {
  // @@protoc_insertion_point(field_get:Schedule.date)
  return date_;
}
inline void Schedule::set_date(::google::protobuf::uint64 value) {
  
  date_ = value;
  // @@protoc_insertion_point(field_set:Schedule.date)
}

// uint64 trading_open_time = 20;
inline void Schedule::clear_trading_open_time() {
  trading_open_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Schedule::trading_open_time() const {
  // @@protoc_insertion_point(field_get:Schedule.trading_open_time)
  return trading_open_time_;
}
inline void Schedule::set_trading_open_time(::google::protobuf::uint64 value) {
  
  trading_open_time_ = value;
  // @@protoc_insertion_point(field_set:Schedule.trading_open_time)
}

// uint64 trading_close_time = 30;
inline void Schedule::clear_trading_close_time() {
  trading_close_time_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Schedule::trading_close_time() const {
  // @@protoc_insertion_point(field_get:Schedule.trading_close_time)
  return trading_close_time_;
}
inline void Schedule::set_trading_close_time(::google::protobuf::uint64 value) {
  
  trading_close_time_ = value;
  // @@protoc_insertion_point(field_set:Schedule.trading_close_time)
}

// repeated string product = 40;
inline int Schedule::product_size() const {
  return product_.size();
}
inline void Schedule::clear_product() {
  product_.Clear();
}
inline const ::std::string& Schedule::product(int index) const {
  // @@protoc_insertion_point(field_get:Schedule.product)
  return product_.Get(index);
}
inline ::std::string* Schedule::mutable_product(int index) {
  // @@protoc_insertion_point(field_mutable:Schedule.product)
  return product_.Mutable(index);
}
inline void Schedule::set_product(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Schedule.product)
  product_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Schedule::set_product(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Schedule.product)
  product_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Schedule::set_product(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  product_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Schedule.product)
}
inline void Schedule::set_product(int index, const char* value, size_t size) {
  product_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Schedule.product)
}
inline ::std::string* Schedule::add_product() {
  // @@protoc_insertion_point(field_add_mutable:Schedule.product)
  return product_.Add();
}
inline void Schedule::add_product(const ::std::string& value) {
  product_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Schedule.product)
}
#if LANG_CXX11
inline void Schedule::add_product(::std::string&& value) {
  product_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Schedule.product)
}
#endif
inline void Schedule::add_product(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  product_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Schedule.product)
}
inline void Schedule::add_product(const char* value, size_t size) {
  product_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Schedule.product)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Schedule::product() const {
  // @@protoc_insertion_point(field_list:Schedule.product)
  return product_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Schedule::mutable_product() {
  // @@protoc_insertion_point(field_mutable_list:Schedule.product)
  return &product_;
}

// -------------------------------------------------------------------

// TradingSession

// string session_id = 10;
inline void TradingSession::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TradingSession::session_id() const {
  // @@protoc_insertion_point(field_get:TradingSession.session_id)
  return session_id_.GetNoArena();
}
inline void TradingSession::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TradingSession.session_id)
}
#if LANG_CXX11
inline void TradingSession::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TradingSession.session_id)
}
#endif
inline void TradingSession::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TradingSession.session_id)
}
inline void TradingSession::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TradingSession.session_id)
}
inline ::std::string* TradingSession::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:TradingSession.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TradingSession::release_session_id() {
  // @@protoc_insertion_point(field_release:TradingSession.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TradingSession::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:TradingSession.session_id)
}

// .Schedule schedule = 20;
inline bool TradingSession::has_schedule() const {
  return this != internal_default_instance() && schedule_ != NULL;
}
inline void TradingSession::clear_schedule() {
  if (GetArenaNoVirtual() == NULL && schedule_ != NULL) {
    delete schedule_;
  }
  schedule_ = NULL;
}
inline const ::Schedule& TradingSession::_internal_schedule() const {
  return *schedule_;
}
inline const ::Schedule& TradingSession::schedule() const {
  const ::Schedule* p = schedule_;
  // @@protoc_insertion_point(field_get:TradingSession.schedule)
  return p != NULL ? *p : *reinterpret_cast<const ::Schedule*>(
      &::_Schedule_default_instance_);
}
inline ::Schedule* TradingSession::release_schedule() {
  // @@protoc_insertion_point(field_release:TradingSession.schedule)
  
  ::Schedule* temp = schedule_;
  schedule_ = NULL;
  return temp;
}
inline ::Schedule* TradingSession::mutable_schedule() {
  
  if (schedule_ == NULL) {
    auto* p = CreateMaybeMessage<::Schedule>(GetArenaNoVirtual());
    schedule_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TradingSession.schedule)
  return schedule_;
}
inline void TradingSession::set_allocated_schedule(::Schedule* schedule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete schedule_;
  }
  if (schedule) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schedule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schedule, submessage_arena);
    }
    
  } else {
    
  }
  schedule_ = schedule;
  // @@protoc_insertion_point(field_set_allocated:TradingSession.schedule)
}

// string prev_session_id = 50;
inline void TradingSession::clear_prev_session_id() {
  prev_session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TradingSession::prev_session_id() const {
  // @@protoc_insertion_point(field_get:TradingSession.prev_session_id)
  return prev_session_id_.GetNoArena();
}
inline void TradingSession::set_prev_session_id(const ::std::string& value) {
  
  prev_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TradingSession.prev_session_id)
}
#if LANG_CXX11
inline void TradingSession::set_prev_session_id(::std::string&& value) {
  
  prev_session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TradingSession.prev_session_id)
}
#endif
inline void TradingSession::set_prev_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  prev_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TradingSession.prev_session_id)
}
inline void TradingSession::set_prev_session_id(const char* value, size_t size) {
  
  prev_session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TradingSession.prev_session_id)
}
inline ::std::string* TradingSession::mutable_prev_session_id() {
  
  // @@protoc_insertion_point(field_mutable:TradingSession.prev_session_id)
  return prev_session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TradingSession::release_prev_session_id() {
  // @@protoc_insertion_point(field_release:TradingSession.prev_session_id)
  
  return prev_session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TradingSession::set_allocated_prev_session_id(::std::string* prev_session_id) {
  if (prev_session_id != NULL) {
    
  } else {
    
  }
  prev_session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), prev_session_id);
  // @@protoc_insertion_point(field_set_allocated:TradingSession.prev_session_id)
}

// -------------------------------------------------------------------

// SessionStatus

// .ExchangeState estate = 10;
inline void SessionStatus::clear_estate() {
  estate_ = 0;
}
inline ::ExchangeState SessionStatus::estate() const {
  // @@protoc_insertion_point(field_get:SessionStatus.estate)
  return static_cast< ::ExchangeState >(estate_);
}
inline void SessionStatus::set_estate(::ExchangeState value) {
  
  estate_ = value;
  // @@protoc_insertion_point(field_set:SessionStatus.estate)
}

// string session_id = 20;
inline void SessionStatus::clear_session_id() {
  session_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SessionStatus::session_id() const {
  // @@protoc_insertion_point(field_get:SessionStatus.session_id)
  return session_id_.GetNoArena();
}
inline void SessionStatus::set_session_id(const ::std::string& value) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:SessionStatus.session_id)
}
#if LANG_CXX11
inline void SessionStatus::set_session_id(::std::string&& value) {
  
  session_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:SessionStatus.session_id)
}
#endif
inline void SessionStatus::set_session_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:SessionStatus.session_id)
}
inline void SessionStatus::set_session_id(const char* value, size_t size) {
  
  session_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:SessionStatus.session_id)
}
inline ::std::string* SessionStatus::mutable_session_id() {
  
  // @@protoc_insertion_point(field_mutable:SessionStatus.session_id)
  return session_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SessionStatus::release_session_id() {
  // @@protoc_insertion_point(field_release:SessionStatus.session_id)
  
  return session_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SessionStatus::set_allocated_session_id(::std::string* session_id) {
  if (session_id != NULL) {
    
  } else {
    
  }
  session_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), session_id);
  // @@protoc_insertion_point(field_set_allocated:SessionStatus.session_id)
}

// -------------------------------------------------------------------

// ExchangeStatus

// .TradingSession session = 10;
inline bool ExchangeStatus::has_session() const {
  return this != internal_default_instance() && session_ != NULL;
}
inline void ExchangeStatus::clear_session() {
  if (GetArenaNoVirtual() == NULL && session_ != NULL) {
    delete session_;
  }
  session_ = NULL;
}
inline const ::TradingSession& ExchangeStatus::_internal_session() const {
  return *session_;
}
inline const ::TradingSession& ExchangeStatus::session() const {
  const ::TradingSession* p = session_;
  // @@protoc_insertion_point(field_get:ExchangeStatus.session)
  return p != NULL ? *p : *reinterpret_cast<const ::TradingSession*>(
      &::_TradingSession_default_instance_);
}
inline ::TradingSession* ExchangeStatus::release_session() {
  // @@protoc_insertion_point(field_release:ExchangeStatus.session)
  
  ::TradingSession* temp = session_;
  session_ = NULL;
  return temp;
}
inline ::TradingSession* ExchangeStatus::mutable_session() {
  
  if (session_ == NULL) {
    auto* p = CreateMaybeMessage<::TradingSession>(GetArenaNoVirtual());
    session_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ExchangeStatus.session)
  return session_;
}
inline void ExchangeStatus::set_allocated_session(::TradingSession* session) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete session_;
  }
  if (session) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      session = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, session, submessage_arena);
    }
    
  } else {
    
  }
  session_ = session;
  // @@protoc_insertion_point(field_set_allocated:ExchangeStatus.session)
}

// .SessionStatus status = 20;
inline bool ExchangeStatus::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void ExchangeStatus::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) {
    delete status_;
  }
  status_ = NULL;
}
inline const ::SessionStatus& ExchangeStatus::_internal_status() const {
  return *status_;
}
inline const ::SessionStatus& ExchangeStatus::status() const {
  const ::SessionStatus* p = status_;
  // @@protoc_insertion_point(field_get:ExchangeStatus.status)
  return p != NULL ? *p : *reinterpret_cast<const ::SessionStatus*>(
      &::_SessionStatus_default_instance_);
}
inline ::SessionStatus* ExchangeStatus::release_status() {
  // @@protoc_insertion_point(field_release:ExchangeStatus.status)
  
  ::SessionStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline ::SessionStatus* ExchangeStatus::mutable_status() {
  
  if (status_ == NULL) {
    auto* p = CreateMaybeMessage<::SessionStatus>(GetArenaNoVirtual());
    status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ExchangeStatus.status)
  return status_;
}
inline void ExchangeStatus::set_allocated_status(::SessionStatus* status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete status_;
  }
  if (status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:ExchangeStatus.status)
}

// -------------------------------------------------------------------

// ActiveContractProduct

// .Contract contract = 10;
inline bool ActiveContractProduct::has_contract() const {
  return this != internal_default_instance() && contract_ != NULL;
}
inline void ActiveContractProduct::clear_contract() {
  if (GetArenaNoVirtual() == NULL && contract_ != NULL) {
    delete contract_;
  }
  contract_ = NULL;
}
inline const ::Contract& ActiveContractProduct::_internal_contract() const {
  return *contract_;
}
inline const ::Contract& ActiveContractProduct::contract() const {
  const ::Contract* p = contract_;
  // @@protoc_insertion_point(field_get:ActiveContractProduct.contract)
  return p != NULL ? *p : *reinterpret_cast<const ::Contract*>(
      &::_Contract_default_instance_);
}
inline ::Contract* ActiveContractProduct::release_contract() {
  // @@protoc_insertion_point(field_release:ActiveContractProduct.contract)
  
  ::Contract* temp = contract_;
  contract_ = NULL;
  return temp;
}
inline ::Contract* ActiveContractProduct::mutable_contract() {
  
  if (contract_ == NULL) {
    auto* p = CreateMaybeMessage<::Contract>(GetArenaNoVirtual());
    contract_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ActiveContractProduct.contract)
  return contract_;
}
inline void ActiveContractProduct::set_allocated_contract(::Contract* contract) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete contract_;
  }
  if (contract) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contract = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contract, submessage_arena);
    }
    
  } else {
    
  }
  contract_ = contract;
  // @@protoc_insertion_point(field_set_allocated:ActiveContractProduct.contract)
}

// .Product product = 20;
inline bool ActiveContractProduct::has_product() const {
  return this != internal_default_instance() && product_ != NULL;
}
inline void ActiveContractProduct::clear_product() {
  if (GetArenaNoVirtual() == NULL && product_ != NULL) {
    delete product_;
  }
  product_ = NULL;
}
inline const ::Product& ActiveContractProduct::_internal_product() const {
  return *product_;
}
inline const ::Product& ActiveContractProduct::product() const {
  const ::Product* p = product_;
  // @@protoc_insertion_point(field_get:ActiveContractProduct.product)
  return p != NULL ? *p : *reinterpret_cast<const ::Product*>(
      &::_Product_default_instance_);
}
inline ::Product* ActiveContractProduct::release_product() {
  // @@protoc_insertion_point(field_release:ActiveContractProduct.product)
  
  ::Product* temp = product_;
  product_ = NULL;
  return temp;
}
inline ::Product* ActiveContractProduct::mutable_product() {
  
  if (product_ == NULL) {
    auto* p = CreateMaybeMessage<::Product>(GetArenaNoVirtual());
    product_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ActiveContractProduct.product)
  return product_;
}
inline void ActiveContractProduct::set_allocated_product(::Product* product) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete product_;
  }
  if (product) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      product = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, product, submessage_arena);
    }
    
  } else {
    
  }
  product_ = product;
  // @@protoc_insertion_point(field_set_allocated:ActiveContractProduct.product)
}

// .Schedule schedule = 30;
inline bool ActiveContractProduct::has_schedule() const {
  return this != internal_default_instance() && schedule_ != NULL;
}
inline void ActiveContractProduct::clear_schedule() {
  if (GetArenaNoVirtual() == NULL && schedule_ != NULL) {
    delete schedule_;
  }
  schedule_ = NULL;
}
inline const ::Schedule& ActiveContractProduct::_internal_schedule() const {
  return *schedule_;
}
inline const ::Schedule& ActiveContractProduct::schedule() const {
  const ::Schedule* p = schedule_;
  // @@protoc_insertion_point(field_get:ActiveContractProduct.schedule)
  return p != NULL ? *p : *reinterpret_cast<const ::Schedule*>(
      &::_Schedule_default_instance_);
}
inline ::Schedule* ActiveContractProduct::release_schedule() {
  // @@protoc_insertion_point(field_release:ActiveContractProduct.schedule)
  
  ::Schedule* temp = schedule_;
  schedule_ = NULL;
  return temp;
}
inline ::Schedule* ActiveContractProduct::mutable_schedule() {
  
  if (schedule_ == NULL) {
    auto* p = CreateMaybeMessage<::Schedule>(GetArenaNoVirtual());
    schedule_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ActiveContractProduct.schedule)
  return schedule_;
}
inline void ActiveContractProduct::set_allocated_schedule(::Schedule* schedule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete schedule_;
  }
  if (schedule) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      schedule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, schedule, submessage_arena);
    }
    
  } else {
    
  }
  schedule_ = schedule;
  // @@protoc_insertion_point(field_set_allocated:ActiveContractProduct.schedule)
}

// -------------------------------------------------------------------

// Position

// sint32 position = 10;
inline void Position::clear_position() {
  position_ = 0;
}
inline ::google::protobuf::int32 Position::position() const {
  // @@protoc_insertion_point(field_get:Position.position)
  return position_;
}
inline void Position::set_position(::google::protobuf::int32 value) {
  
  position_ = value;
  // @@protoc_insertion_point(field_set:Position.position)
}

// uint32 avg_price = 20;
inline void Position::clear_avg_price() {
  avg_price_ = 0u;
}
inline ::google::protobuf::uint32 Position::avg_price() const {
  // @@protoc_insertion_point(field_get:Position.avg_price)
  return avg_price_;
}
inline void Position::set_avg_price(::google::protobuf::uint32 value) {
  
  avg_price_ = value;
  // @@protoc_insertion_point(field_set:Position.avg_price)
}

// -------------------------------------------------------------------

// OrderFills

// .BookOrder order = 10;
inline bool OrderFills::has_order() const {
  return this != internal_default_instance() && order_ != NULL;
}
inline void OrderFills::clear_order() {
  if (GetArenaNoVirtual() == NULL && order_ != NULL) {
    delete order_;
  }
  order_ = NULL;
}
inline const ::BookOrder& OrderFills::_internal_order() const {
  return *order_;
}
inline const ::BookOrder& OrderFills::order() const {
  const ::BookOrder* p = order_;
  // @@protoc_insertion_point(field_get:OrderFills.order)
  return p != NULL ? *p : *reinterpret_cast<const ::BookOrder*>(
      &::_BookOrder_default_instance_);
}
inline ::BookOrder* OrderFills::release_order() {
  // @@protoc_insertion_point(field_release:OrderFills.order)
  
  ::BookOrder* temp = order_;
  order_ = NULL;
  return temp;
}
inline ::BookOrder* OrderFills::mutable_order() {
  
  if (order_ == NULL) {
    auto* p = CreateMaybeMessage<::BookOrder>(GetArenaNoVirtual());
    order_ = p;
  }
  // @@protoc_insertion_point(field_mutable:OrderFills.order)
  return order_;
}
inline void OrderFills::set_allocated_order(::BookOrder* order) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete order_;
  }
  if (order) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      order = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, order, submessage_arena);
    }
    
  } else {
    
  }
  order_ = order;
  // @@protoc_insertion_point(field_set_allocated:OrderFills.order)
}

// repeated .FillData fills = 50;
inline int OrderFills::fills_size() const {
  return fills_.size();
}
inline void OrderFills::clear_fills() {
  fills_.Clear();
}
inline ::FillData* OrderFills::mutable_fills(int index) {
  // @@protoc_insertion_point(field_mutable:OrderFills.fills)
  return fills_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::FillData >*
OrderFills::mutable_fills() {
  // @@protoc_insertion_point(field_mutable_list:OrderFills.fills)
  return &fills_;
}
inline const ::FillData& OrderFills::fills(int index) const {
  // @@protoc_insertion_point(field_get:OrderFills.fills)
  return fills_.Get(index);
}
inline ::FillData* OrderFills::add_fills() {
  // @@protoc_insertion_point(field_add:OrderFills.fills)
  return fills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::FillData >&
OrderFills::fills() const {
  // @@protoc_insertion_point(field_list:OrderFills.fills)
  return fills_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// AccountState

// string sidepit_id = 10;
inline void AccountState::clear_sidepit_id() {
  sidepit_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountState::sidepit_id() const {
  // @@protoc_insertion_point(field_get:AccountState.sidepit_id)
  return sidepit_id_.GetNoArena();
}
inline void AccountState::set_sidepit_id(const ::std::string& value) {
  
  sidepit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AccountState.sidepit_id)
}
#if LANG_CXX11
inline void AccountState::set_sidepit_id(::std::string&& value) {
  
  sidepit_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AccountState.sidepit_id)
}
#endif
inline void AccountState::set_sidepit_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sidepit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AccountState.sidepit_id)
}
inline void AccountState::set_sidepit_id(const char* value, size_t size) {
  
  sidepit_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AccountState.sidepit_id)
}
inline ::std::string* AccountState::mutable_sidepit_id() {
  
  // @@protoc_insertion_point(field_mutable:AccountState.sidepit_id)
  return sidepit_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountState::release_sidepit_id() {
  // @@protoc_insertion_point(field_release:AccountState.sidepit_id)
  
  return sidepit_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountState::set_allocated_sidepit_id(::std::string* sidepit_id) {
  if (sidepit_id != NULL) {
    
  } else {
    
  }
  sidepit_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sidepit_id);
  // @@protoc_insertion_point(field_set_allocated:AccountState.sidepit_id)
}

// string pubkey = 20;
inline void AccountState::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AccountState::pubkey() const {
  // @@protoc_insertion_point(field_get:AccountState.pubkey)
  return pubkey_.GetNoArena();
}
inline void AccountState::set_pubkey(const ::std::string& value) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:AccountState.pubkey)
}
#if LANG_CXX11
inline void AccountState::set_pubkey(::std::string&& value) {
  
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AccountState.pubkey)
}
#endif
inline void AccountState::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AccountState.pubkey)
}
inline void AccountState::set_pubkey(const char* value, size_t size) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AccountState.pubkey)
}
inline ::std::string* AccountState::mutable_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:AccountState.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountState::release_pubkey() {
  // @@protoc_insertion_point(field_release:AccountState.pubkey)
  
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountState::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    
  } else {
    
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:AccountState.pubkey)
}

// int64 net_locked = 30;
inline void AccountState::clear_net_locked() {
  net_locked_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountState::net_locked() const {
  // @@protoc_insertion_point(field_get:AccountState.net_locked)
  return net_locked_;
}
inline void AccountState::set_net_locked(::google::protobuf::int64 value) {
  
  net_locked_ = value;
  // @@protoc_insertion_point(field_set:AccountState.net_locked)
}

// int64 pending_unlock = 40;
inline void AccountState::clear_pending_unlock() {
  pending_unlock_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountState::pending_unlock() const {
  // @@protoc_insertion_point(field_get:AccountState.pending_unlock)
  return pending_unlock_;
}
inline void AccountState::set_pending_unlock(::google::protobuf::int64 value) {
  
  pending_unlock_ = value;
  // @@protoc_insertion_point(field_set:AccountState.pending_unlock)
}

// int64 realized_pnl = 50;
inline void AccountState::clear_realized_pnl() {
  realized_pnl_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountState::realized_pnl() const {
  // @@protoc_insertion_point(field_get:AccountState.realized_pnl)
  return realized_pnl_;
}
inline void AccountState::set_realized_pnl(::google::protobuf::int64 value) {
  
  realized_pnl_ = value;
  // @@protoc_insertion_point(field_set:AccountState.realized_pnl)
}

// int64 unrealized_pnl = 60;
inline void AccountState::clear_unrealized_pnl() {
  unrealized_pnl_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountState::unrealized_pnl() const {
  // @@protoc_insertion_point(field_get:AccountState.unrealized_pnl)
  return unrealized_pnl_;
}
inline void AccountState::set_unrealized_pnl(::google::protobuf::int64 value) {
  
  unrealized_pnl_ = value;
  // @@protoc_insertion_point(field_set:AccountState.unrealized_pnl)
}

// int64 margin_required = 80;
inline void AccountState::clear_margin_required() {
  margin_required_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountState::margin_required() const {
  // @@protoc_insertion_point(field_get:AccountState.margin_required)
  return margin_required_;
}
inline void AccountState::set_margin_required(::google::protobuf::int64 value) {
  
  margin_required_ = value;
  // @@protoc_insertion_point(field_set:AccountState.margin_required)
}

// int64 available_balance = 90;
inline void AccountState::clear_available_balance() {
  available_balance_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountState::available_balance() const {
  // @@protoc_insertion_point(field_get:AccountState.available_balance)
  return available_balance_;
}
inline void AccountState::set_available_balance(::google::protobuf::int64 value) {
  
  available_balance_ = value;
  // @@protoc_insertion_point(field_set:AccountState.available_balance)
}

// int64 available_margin = 100;
inline void AccountState::clear_available_margin() {
  available_margin_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AccountState::available_margin() const {
  // @@protoc_insertion_point(field_get:AccountState.available_margin)
  return available_margin_;
}
inline void AccountState::set_available_margin(::google::protobuf::int64 value) {
  
  available_margin_ = value;
  // @@protoc_insertion_point(field_set:AccountState.available_margin)
}

// bool is_restricted = 110;
inline void AccountState::clear_is_restricted() {
  is_restricted_ = false;
}
inline bool AccountState::is_restricted() const {
  // @@protoc_insertion_point(field_get:AccountState.is_restricted)
  return is_restricted_;
}
inline void AccountState::set_is_restricted(bool value) {
  
  is_restricted_ = value;
  // @@protoc_insertion_point(field_set:AccountState.is_restricted)
}

// int32 reduce_only = 112;
inline void AccountState::clear_reduce_only() {
  reduce_only_ = 0;
}
inline ::google::protobuf::int32 AccountState::reduce_only() const {
  // @@protoc_insertion_point(field_get:AccountState.reduce_only)
  return reduce_only_;
}
inline void AccountState::set_reduce_only(::google::protobuf::int32 value) {
  
  reduce_only_ = value;
  // @@protoc_insertion_point(field_set:AccountState.reduce_only)
}

// map<string, .Position> positions = 120;
inline int AccountState::positions_size() const {
  return positions_.size();
}
inline void AccountState::clear_positions() {
  positions_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::Position >&
AccountState::positions() const {
  // @@protoc_insertion_point(field_map:AccountState.positions)
  return positions_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::Position >*
AccountState::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_map:AccountState.positions)
  return positions_.MutableMap();
}

// sint32 carried_position = 130;
inline void AccountState::clear_carried_position() {
  carried_position_ = 0;
}
inline ::google::protobuf::int32 AccountState::carried_position() const {
  // @@protoc_insertion_point(field_get:AccountState.carried_position)
  return carried_position_;
}
inline void AccountState::set_carried_position(::google::protobuf::int32 value) {
  
  carried_position_ = value;
  // @@protoc_insertion_point(field_set:AccountState.carried_position)
}

// sint32 new_position = 140;
inline void AccountState::clear_new_position() {
  new_position_ = 0;
}
inline ::google::protobuf::int32 AccountState::new_position() const {
  // @@protoc_insertion_point(field_get:AccountState.new_position)
  return new_position_;
}
inline void AccountState::set_new_position(::google::protobuf::int32 value) {
  
  new_position_ = value;
  // @@protoc_insertion_point(field_set:AccountState.new_position)
}

// int32 open_bids = 150;
inline void AccountState::clear_open_bids() {
  open_bids_ = 0;
}
inline ::google::protobuf::int32 AccountState::open_bids() const {
  // @@protoc_insertion_point(field_get:AccountState.open_bids)
  return open_bids_;
}
inline void AccountState::set_open_bids(::google::protobuf::int32 value) {
  
  open_bids_ = value;
  // @@protoc_insertion_point(field_set:AccountState.open_bids)
}

// int32 open_asks = 160;
inline void AccountState::clear_open_asks() {
  open_asks_ = 0;
}
inline ::google::protobuf::int32 AccountState::open_asks() const {
  // @@protoc_insertion_point(field_get:AccountState.open_asks)
  return open_asks_;
}
inline void AccountState::set_open_asks(::google::protobuf::int32 value) {
  
  open_asks_ = value;
  // @@protoc_insertion_point(field_set:AccountState.open_asks)
}

// -------------------------------------------------------------------

// BtcLocks

// string txid = 10;
inline void BtcLocks::clear_txid() {
  txid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BtcLocks::txid() const {
  // @@protoc_insertion_point(field_get:BtcLocks.txid)
  return txid_.GetNoArena();
}
inline void BtcLocks::set_txid(const ::std::string& value) {
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BtcLocks.txid)
}
#if LANG_CXX11
inline void BtcLocks::set_txid(::std::string&& value) {
  
  txid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BtcLocks.txid)
}
#endif
inline void BtcLocks::set_txid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BtcLocks.txid)
}
inline void BtcLocks::set_txid(const char* value, size_t size) {
  
  txid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BtcLocks.txid)
}
inline ::std::string* BtcLocks::mutable_txid() {
  
  // @@protoc_insertion_point(field_mutable:BtcLocks.txid)
  return txid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BtcLocks::release_txid() {
  // @@protoc_insertion_point(field_release:BtcLocks.txid)
  
  return txid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BtcLocks::set_allocated_txid(::std::string* txid) {
  if (txid != NULL) {
    
  } else {
    
  }
  txid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txid);
  // @@protoc_insertion_point(field_set_allocated:BtcLocks.txid)
}

// string pubkey = 20;
inline void BtcLocks::clear_pubkey() {
  pubkey_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BtcLocks::pubkey() const {
  // @@protoc_insertion_point(field_get:BtcLocks.pubkey)
  return pubkey_.GetNoArena();
}
inline void BtcLocks::set_pubkey(const ::std::string& value) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BtcLocks.pubkey)
}
#if LANG_CXX11
inline void BtcLocks::set_pubkey(::std::string&& value) {
  
  pubkey_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BtcLocks.pubkey)
}
#endif
inline void BtcLocks::set_pubkey(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BtcLocks.pubkey)
}
inline void BtcLocks::set_pubkey(const char* value, size_t size) {
  
  pubkey_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BtcLocks.pubkey)
}
inline ::std::string* BtcLocks::mutable_pubkey() {
  
  // @@protoc_insertion_point(field_mutable:BtcLocks.pubkey)
  return pubkey_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BtcLocks::release_pubkey() {
  // @@protoc_insertion_point(field_release:BtcLocks.pubkey)
  
  return pubkey_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BtcLocks::set_allocated_pubkey(::std::string* pubkey) {
  if (pubkey != NULL) {
    
  } else {
    
  }
  pubkey_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pubkey);
  // @@protoc_insertion_point(field_set_allocated:BtcLocks.pubkey)
}

// string btc_address = 30;
inline void BtcLocks::clear_btc_address() {
  btc_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BtcLocks::btc_address() const {
  // @@protoc_insertion_point(field_get:BtcLocks.btc_address)
  return btc_address_.GetNoArena();
}
inline void BtcLocks::set_btc_address(const ::std::string& value) {
  
  btc_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:BtcLocks.btc_address)
}
#if LANG_CXX11
inline void BtcLocks::set_btc_address(::std::string&& value) {
  
  btc_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:BtcLocks.btc_address)
}
#endif
inline void BtcLocks::set_btc_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  btc_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:BtcLocks.btc_address)
}
inline void BtcLocks::set_btc_address(const char* value, size_t size) {
  
  btc_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:BtcLocks.btc_address)
}
inline ::std::string* BtcLocks::mutable_btc_address() {
  
  // @@protoc_insertion_point(field_mutable:BtcLocks.btc_address)
  return btc_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BtcLocks::release_btc_address() {
  // @@protoc_insertion_point(field_release:BtcLocks.btc_address)
  
  return btc_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BtcLocks::set_allocated_btc_address(::std::string* btc_address) {
  if (btc_address != NULL) {
    
  } else {
    
  }
  btc_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), btc_address);
  // @@protoc_insertion_point(field_set_allocated:BtcLocks.btc_address)
}

// uint64 lock_sats = 40;
inline void BtcLocks::clear_lock_sats() {
  lock_sats_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BtcLocks::lock_sats() const {
  // @@protoc_insertion_point(field_get:BtcLocks.lock_sats)
  return lock_sats_;
}
inline void BtcLocks::set_lock_sats(::google::protobuf::uint64 value) {
  
  lock_sats_ = value;
  // @@protoc_insertion_point(field_set:BtcLocks.lock_sats)
}

// uint64 unlock_sats = 50;
inline void BtcLocks::clear_unlock_sats() {
  unlock_sats_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 BtcLocks::unlock_sats() const {
  // @@protoc_insertion_point(field_get:BtcLocks.unlock_sats)
  return unlock_sats_;
}
inline void BtcLocks::set_unlock_sats(::google::protobuf::uint64 value) {
  
  unlock_sats_ = value;
  // @@protoc_insertion_point(field_set:BtcLocks.unlock_sats)
}

// bool is_pending = 60;
inline void BtcLocks::clear_is_pending() {
  is_pending_ = false;
}
inline bool BtcLocks::is_pending() const {
  // @@protoc_insertion_point(field_get:BtcLocks.is_pending)
  return is_pending_;
}
inline void BtcLocks::set_is_pending(bool value) {
  
  is_pending_ = value;
  // @@protoc_insertion_point(field_set:BtcLocks.is_pending)
}

// -------------------------------------------------------------------

// RequestReply

// int32 TypeMask = 1;
inline void RequestReply::clear_typemask() {
  typemask_ = 0;
}
inline ::google::protobuf::int32 RequestReply::typemask() const {
  // @@protoc_insertion_point(field_get:RequestReply.TypeMask)
  return typemask_;
}
inline void RequestReply::set_typemask(::google::protobuf::int32 value) {
  
  typemask_ = value;
  // @@protoc_insertion_point(field_set:RequestReply.TypeMask)
}

// string traderid = 10;
inline void RequestReply::clear_traderid() {
  traderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestReply::traderid() const {
  // @@protoc_insertion_point(field_get:RequestReply.traderid)
  return traderid_.GetNoArena();
}
inline void RequestReply::set_traderid(const ::std::string& value) {
  
  traderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RequestReply.traderid)
}
#if LANG_CXX11
inline void RequestReply::set_traderid(::std::string&& value) {
  
  traderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RequestReply.traderid)
}
#endif
inline void RequestReply::set_traderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  traderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RequestReply.traderid)
}
inline void RequestReply::set_traderid(const char* value, size_t size) {
  
  traderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RequestReply.traderid)
}
inline ::std::string* RequestReply::mutable_traderid() {
  
  // @@protoc_insertion_point(field_mutable:RequestReply.traderid)
  return traderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestReply::release_traderid() {
  // @@protoc_insertion_point(field_release:RequestReply.traderid)
  
  return traderid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestReply::set_allocated_traderid(::std::string* traderid) {
  if (traderid != NULL) {
    
  } else {
    
  }
  traderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), traderid);
  // @@protoc_insertion_point(field_set_allocated:RequestReply.traderid)
}

// string ticker = 30;
inline void RequestReply::clear_ticker() {
  ticker_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RequestReply::ticker() const {
  // @@protoc_insertion_point(field_get:RequestReply.ticker)
  return ticker_.GetNoArena();
}
inline void RequestReply::set_ticker(const ::std::string& value) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:RequestReply.ticker)
}
#if LANG_CXX11
inline void RequestReply::set_ticker(::std::string&& value) {
  
  ticker_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:RequestReply.ticker)
}
#endif
inline void RequestReply::set_ticker(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:RequestReply.ticker)
}
inline void RequestReply::set_ticker(const char* value, size_t size) {
  
  ticker_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:RequestReply.ticker)
}
inline ::std::string* RequestReply::mutable_ticker() {
  
  // @@protoc_insertion_point(field_mutable:RequestReply.ticker)
  return ticker_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RequestReply::release_ticker() {
  // @@protoc_insertion_point(field_release:RequestReply.ticker)
  
  return ticker_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RequestReply::set_allocated_ticker(::std::string* ticker) {
  if (ticker != NULL) {
    
  } else {
    
  }
  ticker_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ticker);
  // @@protoc_insertion_point(field_set_allocated:RequestReply.ticker)
}

// -------------------------------------------------------------------

// ReplyRequest

// int32 TypeMask = 10;
inline void ReplyRequest::clear_typemask() {
  typemask_ = 0;
}
inline ::google::protobuf::int32 ReplyRequest::typemask() const {
  // @@protoc_insertion_point(field_get:ReplyRequest.TypeMask)
  return typemask_;
}
inline void ReplyRequest::set_typemask(::google::protobuf::int32 value) {
  
  typemask_ = value;
  // @@protoc_insertion_point(field_set:ReplyRequest.TypeMask)
}

// .TraderPositionOrders trader_positions = 20;
inline bool ReplyRequest::has_trader_positions() const {
  return this != internal_default_instance() && trader_positions_ != NULL;
}
inline void ReplyRequest::clear_trader_positions() {
  if (GetArenaNoVirtual() == NULL && trader_positions_ != NULL) {
    delete trader_positions_;
  }
  trader_positions_ = NULL;
}
inline const ::TraderPositionOrders& ReplyRequest::_internal_trader_positions() const {
  return *trader_positions_;
}
inline const ::TraderPositionOrders& ReplyRequest::trader_positions() const {
  const ::TraderPositionOrders* p = trader_positions_;
  // @@protoc_insertion_point(field_get:ReplyRequest.trader_positions)
  return p != NULL ? *p : *reinterpret_cast<const ::TraderPositionOrders*>(
      &::_TraderPositionOrders_default_instance_);
}
inline ::TraderPositionOrders* ReplyRequest::release_trader_positions() {
  // @@protoc_insertion_point(field_release:ReplyRequest.trader_positions)
  
  ::TraderPositionOrders* temp = trader_positions_;
  trader_positions_ = NULL;
  return temp;
}
inline ::TraderPositionOrders* ReplyRequest::mutable_trader_positions() {
  
  if (trader_positions_ == NULL) {
    auto* p = CreateMaybeMessage<::TraderPositionOrders>(GetArenaNoVirtual());
    trader_positions_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ReplyRequest.trader_positions)
  return trader_positions_;
}
inline void ReplyRequest::set_allocated_trader_positions(::TraderPositionOrders* trader_positions) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete trader_positions_;
  }
  if (trader_positions) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      trader_positions = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, trader_positions, submessage_arena);
    }
    
  } else {
    
  }
  trader_positions_ = trader_positions;
  // @@protoc_insertion_point(field_set_allocated:ReplyRequest.trader_positions)
}

// .ActiveProduct active_product = 30;
inline bool ReplyRequest::has_active_product() const {
  return this != internal_default_instance() && active_product_ != NULL;
}
inline void ReplyRequest::clear_active_product() {
  if (GetArenaNoVirtual() == NULL && active_product_ != NULL) {
    delete active_product_;
  }
  active_product_ = NULL;
}
inline const ::ActiveProduct& ReplyRequest::_internal_active_product() const {
  return *active_product_;
}
inline const ::ActiveProduct& ReplyRequest::active_product() const {
  const ::ActiveProduct* p = active_product_;
  // @@protoc_insertion_point(field_get:ReplyRequest.active_product)
  return p != NULL ? *p : *reinterpret_cast<const ::ActiveProduct*>(
      &::_ActiveProduct_default_instance_);
}
inline ::ActiveProduct* ReplyRequest::release_active_product() {
  // @@protoc_insertion_point(field_release:ReplyRequest.active_product)
  
  ::ActiveProduct* temp = active_product_;
  active_product_ = NULL;
  return temp;
}
inline ::ActiveProduct* ReplyRequest::mutable_active_product() {
  
  if (active_product_ == NULL) {
    auto* p = CreateMaybeMessage<::ActiveProduct>(GetArenaNoVirtual());
    active_product_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ReplyRequest.active_product)
  return active_product_;
}
inline void ReplyRequest::set_allocated_active_product(::ActiveProduct* active_product) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete active_product_;
  }
  if (active_product) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      active_product = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, active_product, submessage_arena);
    }
    
  } else {
    
  }
  active_product_ = active_product;
  // @@protoc_insertion_point(field_set_allocated:ReplyRequest.active_product)
}

// .MarketData market_data = 40;
inline bool ReplyRequest::has_market_data() const {
  return this != internal_default_instance() && market_data_ != NULL;
}
inline void ReplyRequest::clear_market_data() {
  if (GetArenaNoVirtual() == NULL && market_data_ != NULL) {
    delete market_data_;
  }
  market_data_ = NULL;
}
inline const ::MarketData& ReplyRequest::_internal_market_data() const {
  return *market_data_;
}
inline const ::MarketData& ReplyRequest::market_data() const {
  const ::MarketData* p = market_data_;
  // @@protoc_insertion_point(field_get:ReplyRequest.market_data)
  return p != NULL ? *p : *reinterpret_cast<const ::MarketData*>(
      &::_MarketData_default_instance_);
}
inline ::MarketData* ReplyRequest::release_market_data() {
  // @@protoc_insertion_point(field_release:ReplyRequest.market_data)
  
  ::MarketData* temp = market_data_;
  market_data_ = NULL;
  return temp;
}
inline ::MarketData* ReplyRequest::mutable_market_data() {
  
  if (market_data_ == NULL) {
    auto* p = CreateMaybeMessage<::MarketData>(GetArenaNoVirtual());
    market_data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ReplyRequest.market_data)
  return market_data_;
}
inline void ReplyRequest::set_allocated_market_data(::MarketData* market_data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete market_data_;
  }
  if (market_data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      market_data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, market_data, submessage_arena);
    }
    
  } else {
    
  }
  market_data_ = market_data;
  // @@protoc_insertion_point(field_set_allocated:ReplyRequest.market_data)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TraderPositionOrders

// string traderid = 10;
inline void TraderPositionOrders::clear_traderid() {
  traderid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TraderPositionOrders::traderid() const {
  // @@protoc_insertion_point(field_get:TraderPositionOrders.traderid)
  return traderid_.GetNoArena();
}
inline void TraderPositionOrders::set_traderid(const ::std::string& value) {
  
  traderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TraderPositionOrders.traderid)
}
#if LANG_CXX11
inline void TraderPositionOrders::set_traderid(::std::string&& value) {
  
  traderid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TraderPositionOrders.traderid)
}
#endif
inline void TraderPositionOrders::set_traderid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  traderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TraderPositionOrders.traderid)
}
inline void TraderPositionOrders::set_traderid(const char* value, size_t size) {
  
  traderid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TraderPositionOrders.traderid)
}
inline ::std::string* TraderPositionOrders::mutable_traderid() {
  
  // @@protoc_insertion_point(field_mutable:TraderPositionOrders.traderid)
  return traderid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraderPositionOrders::release_traderid() {
  // @@protoc_insertion_point(field_release:TraderPositionOrders.traderid)
  
  return traderid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraderPositionOrders::set_allocated_traderid(::std::string* traderid) {
  if (traderid != NULL) {
    
  } else {
    
  }
  traderid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), traderid);
  // @@protoc_insertion_point(field_set_allocated:TraderPositionOrders.traderid)
}

// string symbol = 20;
inline void TraderPositionOrders::clear_symbol() {
  symbol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TraderPositionOrders::symbol() const {
  // @@protoc_insertion_point(field_get:TraderPositionOrders.symbol)
  return symbol_.GetNoArena();
}
inline void TraderPositionOrders::set_symbol(const ::std::string& value) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:TraderPositionOrders.symbol)
}
#if LANG_CXX11
inline void TraderPositionOrders::set_symbol(::std::string&& value) {
  
  symbol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:TraderPositionOrders.symbol)
}
#endif
inline void TraderPositionOrders::set_symbol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:TraderPositionOrders.symbol)
}
inline void TraderPositionOrders::set_symbol(const char* value, size_t size) {
  
  symbol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:TraderPositionOrders.symbol)
}
inline ::std::string* TraderPositionOrders::mutable_symbol() {
  
  // @@protoc_insertion_point(field_mutable:TraderPositionOrders.symbol)
  return symbol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TraderPositionOrders::release_symbol() {
  // @@protoc_insertion_point(field_release:TraderPositionOrders.symbol)
  
  return symbol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TraderPositionOrders::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    
  } else {
    
  }
  symbol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), symbol);
  // @@protoc_insertion_point(field_set_allocated:TraderPositionOrders.symbol)
}

// map<string, .OrderFills> orderfills = 40;
inline int TraderPositionOrders::orderfills_size() const {
  return orderfills_.size();
}
inline void TraderPositionOrders::clear_orderfills() {
  orderfills_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::OrderFills >&
TraderPositionOrders::orderfills() const {
  // @@protoc_insertion_point(field_map:TraderPositionOrders.orderfills)
  return orderfills_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::OrderFills >*
TraderPositionOrders::mutable_orderfills() {
  // @@protoc_insertion_point(field_mutable_map:TraderPositionOrders.orderfills)
  return orderfills_.MutableMap();
}

// .AccountState accountstate = 50;
inline bool TraderPositionOrders::has_accountstate() const {
  return this != internal_default_instance() && accountstate_ != NULL;
}
inline void TraderPositionOrders::clear_accountstate() {
  if (GetArenaNoVirtual() == NULL && accountstate_ != NULL) {
    delete accountstate_;
  }
  accountstate_ = NULL;
}
inline const ::AccountState& TraderPositionOrders::_internal_accountstate() const {
  return *accountstate_;
}
inline const ::AccountState& TraderPositionOrders::accountstate() const {
  const ::AccountState* p = accountstate_;
  // @@protoc_insertion_point(field_get:TraderPositionOrders.accountstate)
  return p != NULL ? *p : *reinterpret_cast<const ::AccountState*>(
      &::_AccountState_default_instance_);
}
inline ::AccountState* TraderPositionOrders::release_accountstate() {
  // @@protoc_insertion_point(field_release:TraderPositionOrders.accountstate)
  
  ::AccountState* temp = accountstate_;
  accountstate_ = NULL;
  return temp;
}
inline ::AccountState* TraderPositionOrders::mutable_accountstate() {
  
  if (accountstate_ == NULL) {
    auto* p = CreateMaybeMessage<::AccountState>(GetArenaNoVirtual());
    accountstate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:TraderPositionOrders.accountstate)
  return accountstate_;
}
inline void TraderPositionOrders::set_allocated_accountstate(::AccountState* accountstate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete accountstate_;
  }
  if (accountstate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      accountstate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, accountstate, submessage_arena);
    }
    
  } else {
    
  }
  accountstate_ = accountstate;
  // @@protoc_insertion_point(field_set_allocated:TraderPositionOrders.accountstate)
}

// repeated .BtcLocks locks = 60;
inline int TraderPositionOrders::locks_size() const {
  return locks_.size();
}
inline void TraderPositionOrders::clear_locks() {
  locks_.Clear();
}
inline ::BtcLocks* TraderPositionOrders::mutable_locks(int index) {
  // @@protoc_insertion_point(field_mutable:TraderPositionOrders.locks)
  return locks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::BtcLocks >*
TraderPositionOrders::mutable_locks() {
  // @@protoc_insertion_point(field_mutable_list:TraderPositionOrders.locks)
  return &locks_;
}
inline const ::BtcLocks& TraderPositionOrders::locks(int index) const {
  // @@protoc_insertion_point(field_get:TraderPositionOrders.locks)
  return locks_.Get(index);
}
inline ::BtcLocks* TraderPositionOrders::add_locks() {
  // @@protoc_insertion_point(field_add:TraderPositionOrders.locks)
  return locks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::BtcLocks >&
TraderPositionOrders::locks() const {
  // @@protoc_insertion_point(field_list:TraderPositionOrders.locks)
  return locks_;
}

// -------------------------------------------------------------------

// ActiveProduct

// .ActiveContractProduct active_contract_product = 10;
inline bool ActiveProduct::has_active_contract_product() const {
  return this != internal_default_instance() && active_contract_product_ != NULL;
}
inline void ActiveProduct::clear_active_contract_product() {
  if (GetArenaNoVirtual() == NULL && active_contract_product_ != NULL) {
    delete active_contract_product_;
  }
  active_contract_product_ = NULL;
}
inline const ::ActiveContractProduct& ActiveProduct::_internal_active_contract_product() const {
  return *active_contract_product_;
}
inline const ::ActiveContractProduct& ActiveProduct::active_contract_product() const {
  const ::ActiveContractProduct* p = active_contract_product_;
  // @@protoc_insertion_point(field_get:ActiveProduct.active_contract_product)
  return p != NULL ? *p : *reinterpret_cast<const ::ActiveContractProduct*>(
      &::_ActiveContractProduct_default_instance_);
}
inline ::ActiveContractProduct* ActiveProduct::release_active_contract_product() {
  // @@protoc_insertion_point(field_release:ActiveProduct.active_contract_product)
  
  ::ActiveContractProduct* temp = active_contract_product_;
  active_contract_product_ = NULL;
  return temp;
}
inline ::ActiveContractProduct* ActiveProduct::mutable_active_contract_product() {
  
  if (active_contract_product_ == NULL) {
    auto* p = CreateMaybeMessage<::ActiveContractProduct>(GetArenaNoVirtual());
    active_contract_product_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ActiveProduct.active_contract_product)
  return active_contract_product_;
}
inline void ActiveProduct::set_allocated_active_contract_product(::ActiveContractProduct* active_contract_product) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete active_contract_product_;
  }
  if (active_contract_product) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      active_contract_product = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, active_contract_product, submessage_arena);
    }
    
  } else {
    
  }
  active_contract_product_ = active_contract_product;
  // @@protoc_insertion_point(field_set_allocated:ActiveProduct.active_contract_product)
}

// .ExchangeStatus exchange_status = 20;
inline bool ActiveProduct::has_exchange_status() const {
  return this != internal_default_instance() && exchange_status_ != NULL;
}
inline void ActiveProduct::clear_exchange_status() {
  if (GetArenaNoVirtual() == NULL && exchange_status_ != NULL) {
    delete exchange_status_;
  }
  exchange_status_ = NULL;
}
inline const ::ExchangeStatus& ActiveProduct::_internal_exchange_status() const {
  return *exchange_status_;
}
inline const ::ExchangeStatus& ActiveProduct::exchange_status() const {
  const ::ExchangeStatus* p = exchange_status_;
  // @@protoc_insertion_point(field_get:ActiveProduct.exchange_status)
  return p != NULL ? *p : *reinterpret_cast<const ::ExchangeStatus*>(
      &::_ExchangeStatus_default_instance_);
}
inline ::ExchangeStatus* ActiveProduct::release_exchange_status() {
  // @@protoc_insertion_point(field_release:ActiveProduct.exchange_status)
  
  ::ExchangeStatus* temp = exchange_status_;
  exchange_status_ = NULL;
  return temp;
}
inline ::ExchangeStatus* ActiveProduct::mutable_exchange_status() {
  
  if (exchange_status_ == NULL) {
    auto* p = CreateMaybeMessage<::ExchangeStatus>(GetArenaNoVirtual());
    exchange_status_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ActiveProduct.exchange_status)
  return exchange_status_;
}
inline void ActiveProduct::set_allocated_exchange_status(::ExchangeStatus* exchange_status) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete exchange_status_;
  }
  if (exchange_status) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      exchange_status = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, exchange_status, submessage_arena);
    }
    
  } else {
    
  }
  exchange_status_ = exchange_status;
  // @@protoc_insertion_point(field_set_allocated:ActiveProduct.exchange_status)
}

// .ContractBar contractbar = 30;
inline bool ActiveProduct::has_contractbar() const {
  return this != internal_default_instance() && contractbar_ != NULL;
}
inline void ActiveProduct::clear_contractbar() {
  if (GetArenaNoVirtual() == NULL && contractbar_ != NULL) {
    delete contractbar_;
  }
  contractbar_ = NULL;
}
inline const ::ContractBar& ActiveProduct::_internal_contractbar() const {
  return *contractbar_;
}
inline const ::ContractBar& ActiveProduct::contractbar() const {
  const ::ContractBar* p = contractbar_;
  // @@protoc_insertion_point(field_get:ActiveProduct.contractbar)
  return p != NULL ? *p : *reinterpret_cast<const ::ContractBar*>(
      &::_ContractBar_default_instance_);
}
inline ::ContractBar* ActiveProduct::release_contractbar() {
  // @@protoc_insertion_point(field_release:ActiveProduct.contractbar)
  
  ::ContractBar* temp = contractbar_;
  contractbar_ = NULL;
  return temp;
}
inline ::ContractBar* ActiveProduct::mutable_contractbar() {
  
  if (contractbar_ == NULL) {
    auto* p = CreateMaybeMessage<::ContractBar>(GetArenaNoVirtual());
    contractbar_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ActiveProduct.contractbar)
  return contractbar_;
}
inline void ActiveProduct::set_allocated_contractbar(::ContractBar* contractbar) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete contractbar_;
  }
  if (contractbar) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      contractbar = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, contractbar, submessage_arena);
    }
    
  } else {
    
  }
  contractbar_ = contractbar;
  // @@protoc_insertion_point(field_set_allocated:ActiveProduct.contractbar)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::UnlockRequest_AmountType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UnlockRequest_AmountType>() {
  return ::UnlockRequest_AmountType_descriptor();
}
template <> struct is_proto_enum< ::ExchangeState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ExchangeState>() {
  return ::ExchangeState_descriptor();
}
template <> struct is_proto_enum< ::ReplyRequestTypes> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ReplyRequestTypes>() {
  return ::ReplyRequestTypes_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_sidepit_5fapi_2eproto
